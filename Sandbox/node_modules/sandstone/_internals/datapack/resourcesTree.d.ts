import type { AdvancementType, PredicateType, TAG_TYPES, LootTableType, RecipeType } from "../arguments/index";
import type { CommandArgs } from "./minecraft";
export declare type ResourcePath = readonly [namespace: string, ...path: string[]];
declare type FolderOrFileProperties<T extends Record<string, unknown>, P extends ResourcePath> = {
    path: P;
    children: Map<string, FolderOrFile<T>>;
};
/**
 * Represents either a folder or a resource file.
 *
 * A resource file can have children too.
 */
export declare type FolderOrFile<T extends Record<string, unknown>, P extends ResourcePath = ResourcePath> = FolderOrFileProperties<T, P> & (({
    isResource: true;
} & T) | {
    isResource: false;
});
export declare type File<T extends Record<string, unknown>, P extends ResourcePath = ResourcePath> = FolderOrFileProperties<T, P> & ({
    isResource: true;
} & T);
declare type FunctionProperties = {
    commands: CommandArgs[];
};
export declare type FunctionResource = FolderOrFile<FunctionProperties>;
export declare type TagSingleValue<T> = T | {
    id: T;
    required: boolean;
};
declare type TagProperties = {
    values: TagSingleValue<string>[];
    replace?: boolean;
};
declare type TagPath = readonly [
    namespace: string,
    type: TAG_TYPES,
    ...path: string[]
];
export declare type TagsResource = FolderOrFile<TagProperties, TagPath>;
declare type AdvancementProperties = {
    advancement: AdvancementType<string>;
};
export declare type AdvancementResource = FolderOrFile<AdvancementProperties>;
declare type PredicateProperties = {
    predicate: PredicateType;
};
export declare type PredicateResource = FolderOrFile<PredicateProperties>;
declare type LootTableProperties = {
    lootTable: LootTableType;
};
export declare type LootTableResource = FolderOrFile<LootTableProperties>;
declare type RecipeProperties = {
    recipe: RecipeType<string, string, string>;
};
export declare type RecipeResource = FolderOrFile<RecipeProperties>;
/**
 * Given a resource names, returns the type of resource
 */
export declare type ResourceTypeMap = {
    functions: FunctionResource;
    tags: TagsResource;
    advancements: AdvancementResource;
    predicates: PredicateResource;
    loot_tables: LootTableResource;
    recipes: RecipeResource;
};
export declare type ResourceOnlyTypeMap = {
    functions: File<FunctionProperties>;
    tags: File<TagProperties, TagPath>;
    advancements: File<AdvancementProperties>;
    predicates: File<PredicateProperties>;
    loot_tables: File<LootTableProperties>;
    recipes: File<RecipeProperties>;
};
/**
 * All the resources associated with a namespace.
 */
export declare type NamespaceResources = {
    [key in keyof ResourceTypeMap]: Map<string, ResourceTypeMap[key]>;
};
/**
 * All the namespaces.
 */
export declare type Namespaces = Map<string, NamespaceResources>;
export declare type ResourceTypes = keyof NamespaceResources;
export declare class ResourcesTree {
    namespaces: Namespaces;
    constructor();
    /**
     * Initialize a new namespace.
     */
    protected createNamespace(name: string): NamespaceResources;
    /**
     * Get a resource or a folder from a given path, or undefined if the resource/folder if not found.
     * @param resourcePath the path of the resource/folder, in the format [namespace, folder, folder, resource]
     * @param resourceType the type of the resource/folder
     */
    getResourceOrFolder<T extends ResourceTypes>(resourcePath: ResourceTypeMap[T]['path'], resourceType: T): ResourceTypeMap[T] | undefined;
    /**
     * Get a resource from a given path.
     * Throws an error if the resource if not found, or if it is a folder and not a resource.
     * @param resourcePath the path of the resource, in the format [namespace, folder, subfolder, resource name]
     * @param resourceType the type of the resource
     * @throws An error if the resource is not found, or if it is a folder and not a resource.
     */
    getResource<T extends ResourceTypes>(resourcePath: ResourceTypeMap[T]['path'], resourceType: T, errorMessage?: string): Exclude<ResourceTypeMap[T], {
        isResource: false;
    }>;
    /**
     * Deletes a given resource.
     *
     * @returns Whether the resource existed and was deleted.
     */
    deleteResource(resourcePath: ResourcePath, resourceType: ResourceTypes): boolean;
    /**
     * Get a folder from a given path.
     * Throws an error if the folder if not found, or if it is a resource and not a folder.
     * @param folderPath the path of the folder, in the format [namespace, folder, subfolder]
     * @param folderType the type of the folder
     * @throws An error if the folder is not found, or if it is a resource and not a folder.
     */
    getFolder(folderPath: ResourcePath, folderType: ResourceTypes, errorMessage?: string): Exclude<ResourceTypeMap[typeof folderType], {
        isResource: true;
    }>;
    /**
     * Adds a new resource. Creates the namespace of the resource if it doesn't exists yet.
     *
     * @param resourceType the type of the resource
     * @param resource The resource to add.
     */
    addResource<T extends ResourceTypes, U extends ResourceTypeMap[T]>(resourceType: T, resource: U): U & ResourceTypeMap[T];
    /**
     * Get a given resource, or add it if it already exists.
     *
     * @param resourceType the type of the resource
     * @param resource The resource to add, if it doesn't already exists.
     */
    getOrAddResource<T extends ResourceTypes, U extends ResourceTypeMap[T]>(resourceType: T, resource: U): U & ResourceTypeMap[T];
}
export {};
