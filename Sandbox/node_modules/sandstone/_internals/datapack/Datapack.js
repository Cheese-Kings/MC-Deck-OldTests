"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../commands/index");
const index_2 = require("../flow/index");
const index_3 = require("../resources/index");
const index_4 = require("../variables/index");
const minecraft_1 = require("./minecraft");
const resourcesTree_1 = require("./resourcesTree");
const saveDatapack_1 = require("./saveDatapack");
class Datapack {
    constructor(namespace) {
        this.registerNewObjective = (objective) => {
            if (this.objectives.has(objective.name)) {
                throw new Error(`An objective named "${objective.name}" already exists.`);
            }
            this.objectives.set(objective.name, objective);
        };
        /**
         * Register a new command in the current function.
         * @param commandArgs The arguments of the command to add.
         */
        this.registerNewCommand = (commandArgs) => {
            if (!this.currentFunction || !this.currentFunction.isResource) {
                throw Error('Adding a command outside of a registered function');
            }
            this.currentFunction.commands.push(commandArgs);
        };
        /** UTILS */
        /** Create a new objective */
        this.createObjective = (name, criteria, display) => {
            if (name.length > 16) {
                throw new Error(`Objectives cannot have names with more than 16 characters. Got ${name.length} with objective "${name}".`);
            }
            const objective = index_4.Objective(this.commandsRoot, name, criteria, display);
            this.registerNewObjective(objective);
            return objective;
        };
        /**
         * Creates a dynamic numeric variable, represented by an anonymous & unique score.
         *
         * @param initialValue The initial value of the variable. If left unspecified,
         * or if `undefined`, then the score will not be initialized.
         *
         * @param name A name that can be useful for debugging.
         */
        this.Variable = (initialValue, name) => {
            // Get the objective
            const sandstoneAnonymousName = 'sand_variables';
            const score = this.getCreateObjective(sandstoneAnonymousName, 'dummy', 'Sandstone Anonymous Scores');
            // Get the specific anonymous score
            const id = Datapack.anonymousScoreId;
            Datapack.anonymousScoreId += 1;
            const anonymousScore = score.ScoreHolder(`${name !== null && name !== void 0 ? name : 'anonymous'}_${id}`);
            if (initialValue !== undefined) {
                anonymousScore.set(initialValue);
            }
            return anonymousScore;
        };
        this.Selector = index_4.SelectorCreator.bind(this);
        this.addResource = (name, type, resource) => {
            this.resources.addResource(type, {
                ...resource,
                children: new Map(),
                isResource: true,
                path: this.getResourcePath(name).fullPathWithNamespace,
            });
        };
        /**
         * Creates a Minecraft Function.
         *
         * @param name The name of the function.
         * @param callback A callback containing the commands you want in the Minecraft Function.
         */
        this.mcfunction = (name, callback, options) => {
            const mcfunction = new index_3.McFunction(this, name, callback, options !== null && options !== void 0 ? options : {});
            this.rootFunctions.add(mcfunction);
            const returnFunction = mcfunction.call;
            returnFunction.schedule = mcfunction.schedule;
            returnFunction.getName = mcfunction.getNameFromArgs;
            returnFunction.clearSchedule = mcfunction.clearSchedule;
            return returnFunction;
        };
        this.Advancement = (name, advancement) => new index_3.Advancement(this.commandsRoot, name, advancement);
        this.Predicate = (name, predicate) => new index_3.Predicate(this.commandsRoot, name, predicate);
        this.Tag = (type, name, values, replace) => new index_3.Tag(this, type, name, values, replace);
        this.LootTable = (name, lootTable) => new index_3.LootTable(this, name, lootTable);
        this.Recipe = (name, recipe) => new index_3.Recipe(this, name, recipe);
        /**
         * Saves the datapack to the file system.
         *
         * @param name The name of the Datapack
         * @param options The save options
         */
        this.save = (name, options = {}) => {
            var _a;
            // First, generate all functions
            for (const mcfunction of this.rootFunctions) {
                mcfunction.generateInitialFunction();
            }
            // Then, generate the init function.
            this.createEnterRootFunction('__init__');
            // Start by generating constants
            if (this.constants.size > 0) {
                this.commandsRoot.scoreboard.objectives.add('sandstone_const', 'dummy', [{ text: 'Sandstone Constants' }]);
                this.constants.forEach((constant) => {
                    this.commandsRoot.scoreboard.players.set(constant, 'sandstone_const', constant);
                });
            }
            // Then, generate objectives
            if (this.objectives.size > 0) {
                this.objectives.forEach((objective) => {
                    this.commandsRoot.scoreboard.objectives.add(objective.name, objective.criterion, objective._displayRaw);
                });
            }
            // Delete __init__ function if it's empty
            if (((_a = this.currentFunction) === null || _a === void 0 ? void 0 : _a.isResource) && this.currentFunction.commands.length === 0) {
                this.resources.deleteResource(this.currentFunction.path, 'functions');
            }
            else {
                // Else, put the __init__ function in the minecraft:load tag
                this.addFunctionToTag(minecraft_1.toMcFunctionName(this.currentFunction.path), 'minecraft:tick');
            }
            this.exitRootFunction();
            saveDatapack_1.saveDatapack(this.resources, name, options);
        };
        this.defaultNamespace = namespace;
        this.currentFunction = null;
        this.resources = new resourcesTree_1.ResourcesTree();
        this.objectives = new Map();
        this.constants = new Set();
        this.rootFunctions = new Set();
        this.commandsRoot = new index_1.CommandsRoot(this);
        this.flow = new index_2.Flow(this.commandsRoot);
    }
    /** Get information like the path, namespace etc... from a resource name */
    getResourcePath(resourceName) {
        let namespace = this.defaultNamespace;
        let fullName = resourceName;
        if (resourceName.includes(':')) {
            ([namespace, fullName] = resourceName.split(':'));
        }
        const fullPath = fullName.split('/');
        const name = fullPath[fullPath.length - 1];
        const path = fullPath.slice(0, -1);
        return {
            namespace, path, fullPath, name, fullPathWithNamespace: [namespace, ...fullPath], fullName: `${namespace}:${fullName}`,
        };
    }
    /**
     * Creates and enters a new root Minecraft function.
     *
     * @param functionName The name of the function to create
     */
    createEnterRootFunction(functionName) {
        const functionPath = this.getResourcePath(functionName).fullPathWithNamespace;
        this.currentFunction = this.resources.addResource('functions', {
            children: new Map(), commands: [], isResource: true, path: functionPath,
        });
        return functionPath;
    }
    /**
     * Returns a unique name for a function, from an original name, by checking if it already exists in the given folder.
     * @param functionName the original name for the function.
     * @param folder the folder to check into.
     */
    getUniqueNameFromFolder(functionName, folder) {
        let newName = functionName;
        const newNameTemplate = `${newName}_{}`;
        let i = 2;
        // If the current "new name" already exists in the Datapack, increment `i` and apply the template
        while (folder.children.has(newName)) {
            newName = newNameTemplate.replace('{}', i.toString());
            i += 1;
        }
        return newName;
    }
    /**
     * Get a unique name for a child function of the current function, from an original name.
     * @param childName The original name for the child function.
     */
    getUniqueChildName(childName) {
        if (!this.currentFunction) {
            throw new Error('Trying to get a unique child name outside a root function.');
        }
        return this.getUniqueNameFromFolder(childName, this.currentFunction);
    }
    /**
     * Creates a new child function of the current function.
     * @param functionName The name of the child function.
     */
    createChildFunction(functionName) {
        if (!this.currentFunction) {
            throw Error('Entering child function without registering a root function');
        }
        const childName = this.getUniqueChildName(functionName);
        // Update the current function - it now is the child function.
        const emptyFunction = {
            children: new Map(),
            isResource: true,
            commands: [], path: [...this.currentFunction.path, childName],
        };
        this.currentFunction.children.set(childName, emptyFunction);
        // Return its full minecraft name
        return {
            functionName: minecraft_1.toMcFunctionName(emptyFunction.path),
            childFunction: emptyFunction,
        };
    }
    /**
     * Creates and enters a new child function of the current function.
     * @param functionName The name of the child function.
     */
    createEnterChildFunction(functionName) {
        const { childFunction, functionName: realFunctionName } = this.createChildFunction(functionName);
        this.currentFunction = childFunction;
        // Return its full minecraft name
        return realFunctionName;
    }
    /**
     * Recursively exit the current function of the datapack.
     *
     * If we're in a child function of a root function (or a n-th child), it will exit them too.
     */
    exitRootFunction() {
        if (!this.currentFunction) {
            throw Error('Exiting a not-existing function');
        }
        this.currentFunction = null;
    }
    /**
     * Exit the current child function, and enter the parent function.
     */
    exitChildFunction() {
        if (!this.currentFunction) {
            throw Error('Exiting a not-existing function');
        }
        const parentPath = this.currentFunction.path.slice(0, -1);
        this.currentFunction = this.resources.getResource(parentPath, 'functions');
    }
    /**
     * Register a new numeric constant.
     */
    registerNewConstant(amount) {
        this.constants.add(amount);
    }
    /**
     * Add a function to a given function tag
     */
    addFunctionToTag(mcfunction, tag) {
        const { namespace, fullPath, name } = this.getResourcePath(tag);
        const tickResource = this.resources.getOrAddResource('tags', {
            children: new Map(),
            isResource: true,
            path: [namespace, 'functions', ...fullPath],
            values: [],
            replace: false,
        });
        tickResource.values.push(this.getResourcePath(mcfunction).fullName);
    }
    /** Get an objective, and create it if it does not exists. */
    getCreateObjective(name, criteria, display) {
        try {
            return this.createObjective(name, criteria, display);
        }
        catch (e) {
            return this.objectives.get(name);
        }
    }
}
exports.default = Datapack;
Datapack.anonymousScoreId = 0;
//# sourceMappingURL=Datapack.js.map