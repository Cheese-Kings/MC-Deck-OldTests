"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.saveDatapack = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const filesystem_1 = require("./filesystem");
const packMcMeta_1 = __importDefault(require("./packMcMeta"));
const GRAY = '\x1b[90m';
const CYAN = '\x1b[36m';
const LIGHT_RED = '\x1b[91m';
const GREEN = '\x1b[32m';
const LIGHT_GREEN = '\x1b[92m';
const RESET = '\x1b[0m';
function hasWorld(arg) {
    return Object.prototype.hasOwnProperty.call(arg, 'world');
}
function hasRoot(arg) {
    return Object.prototype.hasOwnProperty.call(arg, 'asRootDatapack');
}
function saveFunction(dataPath, resource, options) {
    if (resource.isResource) {
        const [namespace, ...folders] = resource.path;
        const commands = resource.commands.map((args) => args.join(' '));
        const functionsPath = path_1.default.join(dataPath, namespace, 'functions');
        const fileName = folders.pop();
        const mcFunctionFolder = path_1.default.join(functionsPath, ...folders);
        if (!options.dryRun) {
            filesystem_1.createDirectory(mcFunctionFolder);
            // Write the commands to the file system
            const mcFunctionPath = path_1.default.join(mcFunctionFolder, `${fileName}.mcfunction`);
            fs_1.default.writeFileSync(mcFunctionPath, commands.join('\n'));
        }
        const commandsRepresentation = commands.map((command) => {
            if (command.startsWith('#')) {
                return GRAY + command + RESET;
            }
            return command;
        }).join('\n');
        if (options.verbose) {
            console.log(`${CYAN}## Function ${namespace}:${[...folders, fileName].join('/')}${RESET}`);
            console.log(commandsRepresentation);
            console.log();
        }
    }
    Array.from(resource.children.values()).forEach((v) => saveFunction(dataPath, v, options));
}
function saveResource(dataPath, type, resource, options, getRepresentation, getDisplayTitle) {
    if (resource.isResource) {
        const [namespace, ...folders] = resource.path;
        const basePath = path_1.default.join(dataPath, namespace, type);
        const fileName = folders.pop();
        const resourceFolder = path_1.default.join(basePath, ...folders);
        if (!options.dryRun) {
            filesystem_1.createDirectory(resourceFolder);
            // Write the commands to the file system
            const resourcePath = path_1.default.join(resourceFolder, `${fileName}.${type === 'functions' ? 'mcfunction' : 'json'}`);
            fs_1.default.writeFileSync(resourcePath, getRepresentation(resource, false));
        }
        if (options.verbose) {
            console.log(`${CYAN}## ${getDisplayTitle(namespace, folders, fileName)} ${RESET}`);
            console.log(getRepresentation(resource, true));
            console.log();
        }
    }
    for (const r of resource.children.values()) {
        saveResource(dataPath, type, r, options, getRepresentation, getDisplayTitle);
    }
}
/**
 * Saves the datapack to the file system.
 *
 * @param functions A mapping between function full names and their commands.
 * @param name The name of the Datapack
 * @param options The save options.
 */
function saveDatapack(resources, name, options) {
    try {
        // Start by clearing the console
        let savePath;
        if (hasWorld(options)) {
            savePath = path_1.default.join(filesystem_1.getWorldPath(options === null || options === void 0 ? void 0 : options.world, options === null || options === void 0 ? void 0 : options.minecraftPath), 'datapacks');
        }
        else if (hasRoot(options)) {
            savePath = path_1.default.join(filesystem_1.getMinecraftPath(), 'datapacks/');
        }
        else {
            savePath = process.cwd();
        }
        savePath = path_1.default.join(savePath, name);
        const dataPath = path_1.default.join(savePath, 'data');
        if (options.description !== undefined) {
            packMcMeta_1.default.pack.description = options.description;
        }
        if (!options.dryRun) {
            filesystem_1.deleteDirectory(savePath);
            filesystem_1.createDirectory(savePath);
            fs_1.default.writeFileSync(path_1.default.join(savePath, 'pack.mcmeta'), JSON.stringify(packMcMeta_1.default));
        }
        for (const n of resources.namespaces.values()) {
            // Save functions
            for (const f of n.functions.values()) {
                saveResource(dataPath, 'functions', f, options, 
                // To display a function, we join their arguments. If we're in a console display, we put comments in gray.
                (func, consoleDisplay) => {
                    const repr = func.commands.map((command) => command.join(' ')).join('\n');
                    if (consoleDisplay) {
                        return repr.replace(/^#(.+)/gm, `${GRAY}#$1${RESET}`);
                    }
                    return repr;
                }, (namespace, folders, fileName) => `Function ${namespace}:${[...folders, fileName].join('/')}`);
            }
            // Save tags
            for (const t of n.tags.values()) {
                saveResource(dataPath, 'tags', t, options, (r) => { var _a; return JSON.stringify({ replace: (_a = r.replace) !== null && _a !== void 0 ? _a : false, values: r.values }, null, 2); }, (namespace, folders, fileName) => `Tag[${folders[0]}] ${namespace}:${[...folders.slice(1), fileName].join('/')}`);
            }
            // Save advancements
            for (const a of n.advancements.values()) {
                saveResource(dataPath, 'advancements', a, options, (r) => JSON.stringify(r.advancement, null, 2), (namespace, folders, fileName) => `Avancement ${namespace}:${[...folders, fileName].join('/')}`);
            }
            // Save predicates
            for (const p of n.predicates.values()) {
                saveResource(dataPath, 'predicates', p, options, (r) => JSON.stringify(r.predicate, null, 2), (namespace, folders, fileName) => `Predicate ${namespace}:${[...folders, fileName].join('/')}`);
            }
            // Save loot tables
            for (const l of n.loot_tables.values()) {
                saveResource(dataPath, 'loot_tables', l, options, (r) => JSON.stringify(r.lootTable, null, 2), (namespace, folders, fileName) => `Loot table ${namespace}:${[...folders, fileName].join('/')}`);
            }
            // Save recipe
            for (const r of n.recipes.values()) {
                saveResource(dataPath, 'recipes', r, options, (resource) => JSON.stringify(resource.recipe, null, 2), (namespace, folders, fileName) => `Recipe ${namespace}:${[...folders, fileName].join('/')}`);
            }
        }
        if (!options.dryRun) {
            console.log(`${LIGHT_GREEN}✓ Successfully wrote datapack to "${savePath}"${RESET}`);
        }
    }
    catch (e) {
        console.log(`${LIGHT_RED}✗ Failed to write datapack. See above for additional information.${RESET}`);
    }
}
exports.saveDatapack = saveDatapack;
//# sourceMappingURL=saveDatapack.js.map