"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourcesTree = void 0;
class ResourcesTree {
    constructor() {
        this.namespaces = new Map();
    }
    /**
     * Initialize a new namespace.
     */
    createNamespace(name) {
        const namespaceResource = {
            functions: new Map(),
            tags: new Map(),
            advancements: new Map(),
            predicates: new Map(),
            loot_tables: new Map(),
            recipes: new Map(),
        };
        this.namespaces.set(name, namespaceResource);
        return namespaceResource;
    }
    /**
     * Get a resource or a folder from a given path, or undefined if the resource/folder if not found.
     * @param resourcePath the path of the resource/folder, in the format [namespace, folder, folder, resource]
     * @param resourceType the type of the resource/folder
     */
    getResourceOrFolder(resourcePath, resourceType) {
        if (resourcePath.length < 2) {
            throw new Error(`Cannot access resource path with less than 1 arguments, namely "${resourcePath}". This is an internal error.`);
        }
        // Get the namespace name, first folder and path
        const [namespaceName, firstFolder, ...path] = resourcePath;
        // Get the namespace resource
        const namespace = this.namespaces.get(namespaceName);
        if (!namespace) {
            throw new Error(`Unknown namespace ${namespace}. This is an internal error.`);
        }
        // Find the resource
        const result = path.reduce((resource, folder) => (resource ? resource.children.get(folder) : undefined), namespace[resourceType].get(firstFolder));
        return result;
    }
    /**
     * Get a resource from a given path.
     * Throws an error if the resource if not found, or if it is a folder and not a resource.
     * @param resourcePath the path of the resource, in the format [namespace, folder, subfolder, resource name]
     * @param resourceType the type of the resource
     * @throws An error if the resource is not found, or if it is a folder and not a resource.
     */
    getResource(resourcePath, resourceType, errorMessage = `Impossible to find resource ${resourcePath}. This is an internal error.`) {
        const resource = this.getResourceOrFolder(resourcePath, resourceType);
        if (!resource || !resource.isResource) {
            throw new Error(errorMessage);
        }
        return resource;
    }
    /**
     * Deletes a given resource.
     *
     * @returns Whether the resource existed and was deleted.
     */
    deleteResource(resourcePath, resourceType) {
        var _a, _b, _c;
        if (resourcePath.length > 2) {
            const parentResource = this.getResourceOrFolder(resourcePath.slice(0, -1), resourceType);
            return (_a = parentResource === null || parentResource === void 0 ? void 0 : parentResource.children.delete(resourcePath[resourcePath.length - 1])) !== null && _a !== void 0 ? _a : false;
        }
        const namespace = (_b = this.namespaces.get(resourcePath[0])) === null || _b === void 0 ? void 0 : _b[resourceType];
        return (_c = namespace === null || namespace === void 0 ? void 0 : namespace.delete(resourcePath[1])) !== null && _c !== void 0 ? _c : false;
    }
    /**
     * Get a folder from a given path.
     * Throws an error if the folder if not found, or if it is a resource and not a folder.
     * @param folderPath the path of the folder, in the format [namespace, folder, subfolder]
     * @param folderType the type of the folder
     * @throws An error if the folder is not found, or if it is a resource and not a folder.
     */
    getFolder(folderPath, folderType, errorMessage = `Impossible to find folder ${folderPath}. This is an internal error.`) {
        const resource = this.getResourceOrFolder(folderPath, folderType);
        if (!resource || resource.isResource) {
            throw new Error(errorMessage);
        }
        return resource;
    }
    /**
     * Adds a new resource. Creates the namespace of the resource if it doesn't exists yet.
     *
     * @param resourceType the type of the resource
     * @param resource The resource to add.
     */
    addResource(resourceType, resource) {
        const parentPath = resource.path.slice(0, -1);
        const namespace = parentPath[0];
        if (!this.namespaces.has(namespace)) {
            this.createNamespace(namespace);
        }
        if (parentPath.length >= 2) {
            let parent = this.getResourceOrFolder(parentPath, resourceType);
            if (!parent) {
                this.addResource(resourceType, {
                    children: new Map(),
                    isResource: false,
                    path: parentPath,
                });
                parent = this.getResourceOrFolder(parentPath, resourceType);
            }
            parent.children.set(resource.path[resource.path.length - 1], resource);
        }
        else {
            // Our parent path only has one component, the namespace. We need to add the resource like this.
            const namespaceResource = this.namespaces.get(namespace);
            namespaceResource[resourceType].set(resource.path[1], resource);
        }
        return resource;
    }
    /**
     * Get a given resource, or add it if it already exists.
     *
     * @param resourceType the type of the resource
     * @param resource The resource to add, if it doesn't already exists.
     */
    getOrAddResource(resourceType, resource) {
        try {
            return this.getResource(resource.path, resourceType);
        }
        catch (e) {
            return this.addResource(resourceType, resource);
        }
    }
}
exports.ResourcesTree = ResourcesTree;
//# sourceMappingURL=resourcesTree.js.map