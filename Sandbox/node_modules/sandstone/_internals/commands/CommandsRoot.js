"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandsRoot = void 0;
const index_1 = require("../variables/index");
const JsonTextComponentClass_1 = require("../variables/JsonTextComponentClass");
const index_2 = require("../index");
const decorators_1 = require("./decorators");
const index_3 = require("./implementations/index");
class CommandsRoot {
    constructor(datapack) {
        /**
         * Registers the current command.
         *
         * @param soft If true, then it allows to try to register a command when we don't know if it is needed.
         * Sometimes, is is possible a command needs to be registered, or maybe it's not. Then a soft register is necessary.
         */
        this.register = (soft = false) => {
            if (this.executable) {
                // We remove undefined arguments!
                this.Datapack.registerNewCommand(this.arguments.filter((arg) => arg !== undefined));
                this.reset();
                return;
            }
            if (!soft) {
                throw new Error(`Registering a command that is not executable: ${this.arguments.join(' ')}`);
            }
            // Soft registering. If the last command had arguments but was not executable, it's an error.
            if (this.arguments.length > 0) {
                throw new Error(`Error: the previous command ${this.arguments} was not finished.`);
            }
        };
        /**
         * Add some arguments to the current ones, then registers them.
         * It will explicitely set the resulting command as executable.
         */
        this.addAndRegister = (...args) => {
            this.arguments.push(...args);
            this.executable = true;
            this.register();
        };
        /** COMMANDS */
        // advancement command //
        this.advancement = new index_3.AdvancementCommand(this);
        // attribute command //
        this.attribute = (new index_3.Attribute(this)).attribute;
        // bossabar command //
        this.bossbar = new index_3.Bossbar(this);
        /**
         * Clears items from player inventory, including items being dragged by the player.
         *
         * @param targets Specifies the player(s) whose items are cleared.
         * If not specified, defaults to the player who executes the command.
         *
         * @param item Specifies the item to be cleared. If not specified, all items are cleared.
         *
         * @param maxCount Specifies the maximum number of items to be cleared.
         *
         * If not specified, all items that match `item` are cleared.
         *
         * If `0`, instead of clearing of items, detectes and queries the amount of specified items.
         */
        this.clear = (targets, item, maxCount) => { };
        // clone command //
        this.clone = (new index_3.Clone(this)).clone;
        // Add a comment //
        /**
         * Adds a comment, starting with a `#`, to the function.
         */
        this.comment = (...comments) => { };
        // data command //
        this.data = new index_3.Data(this);
        // datapack command //
        this.datapack = new index_3.DatapackCommand(this);
        // debug command //
        this.debug = new index_3.Debug(this);
        // defaultgamemode command //
        this.defaultgamemode = (new index_3.DefaultGamemode(this)).defaultgamemode;
        // difficulty command //
        this.difficulty = (new index_3.Difficulty(this)).difficulty;
        // effect command //
        this.effect = (new index_3.Effect(this));
        // enchant command //
        this.enchant = (new index_3.Enchant(this)).enchant;
        // execute command //
        this.execute = (new index_3.ExecuteWithRun(this));
        // experience command //
        this.experience = new index_3.Experience(this);
        // fill command //
        this.fill = (new index_3.Fill(this)).fill;
        // forceload command //
        this.forceload = new index_3.Forceload(this);
        // function command //
        this.function = (new index_3.FunctionCommand(this).function);
        /**
         * Sets a player's game mode.
         *
         * @param gamemode Specifies the new game mode. Must be one of the following:
         * - `survival` for survival mode
         * - `creative` for creative mode
         * - `adventure` for adventure mode
         * - `spectator` for spectator modeâ€Œ
         *
         * @param targets Specifies the target(s). If not specified, defaults to the player who executes the command.
         */
        this.gamemode = (gamemode, targets) => { };
        // gamerule command //
        this.gamerule = (new index_3.GameruleCommand(this)).gamerule;
        /**
         * Gives an item to one or more players.
         *
         * @param targets Specifies the target(s) to give item(s) to.
         *
         * @param item Specifies the item to give.
         *
         * @param count Specifies the number of items to give. If not specified, defaults to `1`.
         */
        this.give = (targets, item, count) => { };
        /**
         * Shows usages for one command, or lists of commands.
         *
         * @param command_ Specifies the command name to provide help for.
         * Entering more specific parameters of that command is allowed.
         *
         * If unspecified, lists all commands.
         *
         * @param parameters More specific parameters of the command.
         */
        this.help = (command_, ...parameters) => { };
        // kill command //
        /**
         * Kills entities (players, mobs, items, etc.).
         *
         * @param targets Specifies the target(s) to kill. If not specified, defaults to the executor who executed the command.
         */
        this.kill = (targets) => { };
        // list command //
        /**
         * Shows the names of all currently-connected players.
         *
         * @param uuid Whether to show player UUIDs alongside names. Defaults to false.
         */
        this.list = (uuids) => { };
        // locate command //
        /**
         * Displays the coordinates for the closest generated structure of a given type in the chat for the player who executed the command.
         *
         * @param structure Specifies the structure to locate.
         */
        this.locate = (structure) => { };
        // locatebiome command //
        /**
         * Displays the coordinates for the closest biome of a given biome ID in the chat for the player who executed the command.
         *
         * @param biome Specifies the biome to be located.
         */
        this.locatebiome = (biome) => { };
        // loot command //
        this.loot = new index_3.Loot(this);
        // me command //
        /**
         * Displays a message about yourself.
         *
         * @param actions Specifies the messages to display. They will be joined with a whitespace.
         *
         * Each action can be a message or a selector.
         * The game replaces entity selectors in the message with the list of selected entities' names,
         * which is formatted as "name1 and name2" for two entities, or "name1, name2, ... and namen" for n entities.
         */
        this.me = (...actions) => { };
        // particle command //
        this.particle = (new index_3.Particle(this)).particle;
        // playsound command //
        /**
         * Plays a specified sound at a player, in a location, and in a specific volume and pitch.
         *
         * @param sound Specifies the sound to play.
         *
         * A sound event may be affiliated with multiple sounds, and the sound that is actually produced is chosen at random from them,
         * modified by their "weight", just as the game normally would.
         * For example, the `entity.pig.ambient` sound event plays one of several pig sounds at random,
         * because the event has multiple sounds associated with it.
         *
         * Resource packs may add their own events to `sounds.json`; the command successfully plays these.
         * File names are not used by this command; it strictly uses the events defined in `sounds.json`
         * (which may not even be similar to the original file names and paths),
         * and thus a resource pack adding new sound files must define events for them
         * (this is not necessary when replacing old sounds already defined in events).
         *
         * @param source Specifies the music category and options the sound falls under.
         *
         * @param targets Specifies the sound's target.
         */
        this.playsound = (sound, source, targets, sourcePosition, volume, pitch, minVolume) => { };
        // recipe command //
        this.recipe = new index_3.RecipeCommand(this);
        // reload command //
        /**
         * Reloads the current data packs.
         *
         * If a data pack has invalid data (such as an invalid recipe format),
         * changes are not applied and the game continues using the previous data.[
         */
        this.reload = () => { };
        /**
         * A raw command. Can be used to create custom commands, for mods or plugins for example.
         *
         * @example
         * // A custom `mount` command, that takes a player and an entity as argument
         * const self = Selector(`@s`)
         * const nearestSkeleton = Selector(`@e`, { limit: 1, sort: 'nearest' })
         *
         * raw('mount', self, nearestSkeleton)
         */
        this.raw = (...args) => { };
        // replaceitem command //
        this.replaceitem = new index_3.ReplaceItem(this);
        // say command //
        /**
         * Sends a message in the chat.
         *
         * @param messages Specifies the messages to say.
         * All messages will be joined with a whitespace.
         *
         * Each message must be a plain text, or a target selectors.
         * The game replaces entity selectors in the message with the list of selected entities' names, which is formatted as "name1 and name2" for two entities,
         * or "name1, name2, ... and namen" for n entities.
         */
        this.say = (...messages) => { };
        // schedule command //
        this.schedule = new index_3.Schedule(this);
        // scoreboard command //
        this.scoreboard = new index_3.Scoreboard(this);
        // seed command //
        /** Displays the world seed. */
        this.seed = () => { };
        // setblock command //
        /**
         * Changes a block to another block.
         *
         * @param pos Specifies the position of the block to be changed.
         *
         * @param block Specifies the new block.
         *
         * @param type Specifies how to handle the block change. Must be one of:
         * - `destroy`: The old block drops both itself and its contents (as if destroyed by a player). Plays the appropriate block breaking noise.
         * - `keep`: Only air blocks are changed (non-air blocks are unchanged).
         * - `replace`: The old block drops neither itself nor any contents. Plays no sound.
         *
         * If not specified, defaults to `replace`.
         */
        this.setblock = (pos, block, type) => { };
        // setidletimeout command //
        /**
         * Sets the time before idle players are kicked from the server.
         *
         * @param minutes Specifies the idle kick timer.
         */
        this.setidletimeout = (minutes) => { };
        // setworldspawn command //
        /**
         * Sets the world spawn.
         *
         * @param pos Specifies the coordinates of the world spawn. If not specified, defaults to the block position of the command's execution.
         *
         * @param angle Specified the yaw angle to spawn with. Defaults to the direction the executor is facing.
         */
        this.setworldspawn = (pos, angle) => { };
        // spawnpoint command //
        /**
         * Sets the spawn point for a player. You can now set your spawnpoint in the Nether and End.
         *
         * @param targets Specifies the player whose spawn point should be set.
         * If not specified, defaults to the command's executor.
         *
         * @param pos Specifies the coordinates of the player's new spawn point.
         * If not specified, defaults to the position of the command's executor in Java Edition.
         *
         * @param angle Specifies the yaw angle to spawn with. Defaults to the direction the executor is facing.
         */
        this.spawnpoint = (targets, pos, angle) => { };
        // spectate command //
        /**
         * Causes a player in Spectator mode to spectate another entity.
         *
         * @param targets Specifies the target to be spectated.
         *
         * @param player Specifies the spectating player. If unspecified, defaults to the executor.
         */
        this.spectate = (target, player) => { };
        // spreadplayers command //
        this.spreadplayers = (new index_3.SpreadPlayers(this)).spreadplayers;
        /**
         * Stops a given sound.
         *
         * @param targets Specifies the command's target.
         *
         * @param source Specifies which category in the Music & Sound options the sound falls under. If it is *, stop sound of all category.
         *
         * @param sound Specifies the sound to stop.
         */
        this.stopsound = (targets, source, sound) => { };
        /**
         * Summons an entity.
         *
         * @param entity Specifies the entity to be summoned.
         *
         * @param pos Specifies the position to summon the entity. If not specified, defaults to the position of the command's execution.
         *
         * @param nbt Specifies the data tag for the entity.
         */
        this.summon = (entity, pos, nbt) => { };
        // tag command //
        this.tag = (new index_3.TagCommand(this)).tag;
        // team command //
        this.team = new index_3.Team(this);
        // teammessage command //
        /**
         * Specifies a message to send to team.
         *
         * @param messages Must be plain text messages.
         * Can include spaces as well as target selectors.
         * The game replaces entity selectors in the message with the list of selected entities' names,
         * which is formatted as "name1 and name2" for two entities, or "name1, name2, ... and namen" for n entities.
         *
         * At least one message is necesarry.
         */
        this.teammessage = (...messages) => { };
        // teleport command //
        this.teleport = (new index_3.Teleport(this)).teleport;
        // tell command //
        /**
         * Sends a private message to one or more players.
         * @param targets Specifies the player(s) to send the message to.
         * @param messages Specified the message to tell. They will be joined with whitespaces.
         * Can include target selectors.
         * The game replaces entity selectors in the message with the list of selected entities' names,
         * which is formatted as "name1 and name2" for two entities, or "name1, name2, ... and namen" for n entities.
         */
        this.tell = (targets, ...messages) => { };
        // tellraw command //
        this.tellraw = (targets, message) => { };
        // time command //
        this.time = new index_3.Time(this);
        // title command //
        this.title = (new index_3.Title(this)).title;
        // trigger command //
        this.trigger = (new index_3.Trigger(this)).trigger;
        this.weather = new index_3.Weather(this);
        this.worldborder = new index_3.WorldBorder(this);
        /// ALIAS COMMANDS ///
        // msg command //
        this.msg = (...args) => this.tell(...args);
        // w command //
        this.w = (...args) => this.tell(...args);
        // xp command //
        this.xp = this.experience;
        this.arguments = [];
        this.inExecute = false;
        this.executable = false;
        this.Datapack = datapack;
        this.commandsRoot = this;
    }
    reset() {
        this.arguments = [];
        this.inExecute = false;
        this.executable = false;
    }
}
__decorate([
    decorators_1.command('clear', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "clear", void 0);
__decorate([
    decorators_1.command('#', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "comment", void 0);
__decorate([
    decorators_1.command('gamemode', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "gamemode", void 0);
__decorate([
    decorators_1.command('give', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "give", void 0);
__decorate([
    decorators_1.command('help', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "help", void 0);
__decorate([
    decorators_1.command('kill', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "kill", void 0);
__decorate([
    decorators_1.command('list', {
        isRoot: true,
        parsers: {
            '0': (uuids) => (uuids ? 'uuids' : undefined),
        },
    }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "list", void 0);
__decorate([
    decorators_1.command('locate', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "locate", void 0);
__decorate([
    decorators_1.command('locatebiome', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "locatebiome", void 0);
__decorate([
    decorators_1.command('me', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "me", void 0);
__decorate([
    decorators_1.command('playsound', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "playsound", void 0);
__decorate([
    decorators_1.command('reload', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "reload", void 0);
__decorate([
    decorators_1.command([], { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "raw", void 0);
__decorate([
    decorators_1.command('say', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "say", void 0);
__decorate([
    decorators_1.command('seed', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "seed", void 0);
__decorate([
    decorators_1.command('setblock', { isRoot: true, parsers: { '0': index_2.coordinatesParser } }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "setblock", void 0);
__decorate([
    decorators_1.command('setidletimeout', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "setidletimeout", void 0);
__decorate([
    decorators_1.command('setworldspawn', { isRoot: true, parsers: { '0': index_2.coordinatesParser, '1': index_2.rotationParser } }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "setworldspawn", void 0);
__decorate([
    decorators_1.command('spawnpoint', { isRoot: true, parsers: { '1': index_2.coordinatesParser, '2': index_2.rotationParser } }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "spawnpoint", void 0);
__decorate([
    decorators_1.command('spectate', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "spectate", void 0);
__decorate([
    decorators_1.command('stopsound', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "stopsound", void 0);
__decorate([
    decorators_1.command('summon', { isRoot: true, parsers: { '2': index_1.nbtParser } }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "summon", void 0);
__decorate([
    decorators_1.command('teammessage', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "teammessage", void 0);
__decorate([
    decorators_1.command('tell', { isRoot: true }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "tell", void 0);
__decorate([
    decorators_1.command('tellraw', { isRoot: true, parsers: { '1': (msg) => new JsonTextComponentClass_1.JsonTextComponentClass(msg) } }),
    __metadata("design:type", Object)
], CommandsRoot.prototype, "tellraw", void 0);
exports.CommandsRoot = CommandsRoot;
exports.default = CommandsRoot;
//# sourceMappingURL=CommandsRoot.js.map