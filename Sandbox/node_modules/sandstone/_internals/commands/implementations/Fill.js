"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Fill = exports.FillArguments = void 0;
const Command_1 = require("../Command");
const decorators_1 = require("../decorators");
const index_1 = require("../../variables/index");
class FillArguments extends Command_1.Command {
    constructor() {
        super(...arguments);
        /**
         * Replaces all blocks (including air) in the fill region with the specified block,
         * dropping the existing blocks (including those that are unchanged) and block contents as entities,
         * as if they had been mined with an unenchanted diamond shovel or pickaxe.
         *
         * (Blocks that can be mined only with shears, such as vines, do not drop; neither do liquids.)
         */
        this.destroy = () => { };
        /** Replaces only the blocks on the outer edge of the fill region with the specified block.
         *
         * Inner blocks are changed to air, dropping their contents as entities but not themselves.
         *
         * If the fill region has no inner blocks (because it is smaller than three blocks in at least one dimension),
         * acts like `replace`. */
        this.hollow = () => { };
        /**
         * Replaces only the air blocks in the fill region with the specified block.
         */
        this.keep = () => { };
        /**
         * Replaces only the blocks on the outer edge of the fill region with the specified block.
         *
         * Inner blocks are not affected.
         *
         * If the fill region has no inner blocks (because it is smaller than three blocks in at least one dimension),
         * acts like `replace`.
         */
        this.outline = () => { };
        /** Replaces all blocks (including air) in the fill region with the specified block,
         * without dropping blocks or block contents as entities.
         *
         * Optionally, instead of specifying a data tag for the replacing block,
         * block ID and data values may be specified to limit which blocks are replaced.
         *
         * @example
         * // Replace only furnaces facing north, with a BurnTime of 200 ticks:
         * fill(...).replace('minecraft:furnace[facing=north]{BurnTime:200}')
         */
        this.replace = (filter) => { };
    }
}
__decorate([
    decorators_1.command('destroy'),
    __metadata("design:type", Object)
], FillArguments.prototype, "destroy", void 0);
__decorate([
    decorators_1.command('hollow'),
    __metadata("design:type", Object)
], FillArguments.prototype, "hollow", void 0);
__decorate([
    decorators_1.command('keep'),
    __metadata("design:type", Object)
], FillArguments.prototype, "keep", void 0);
__decorate([
    decorators_1.command('outline'),
    __metadata("design:type", Object)
], FillArguments.prototype, "outline", void 0);
__decorate([
    decorators_1.command('replace'),
    __metadata("design:type", Object)
], FillArguments.prototype, "replace", void 0);
exports.FillArguments = FillArguments;
class Fill extends Command_1.Command {
    constructor() {
        super(...arguments);
        /**
         * Fills all or parts of a region with a specific block.
         *
         * @param from
         * Specifies the first corner blocks of the region to be filled (the "fill region").
         *
         * Block position is the coordinates of the point at the lower northwest corner of a block,
         * corresponding to the lowest X-axis, Y-axis and Z-axis point of the block.
         *
         * @param to
         * Specifies the second, opposite corner blocks of the region to be filled (the "fill region").
         *
         * @param block Specifies the block to fill the region with.
         *
         * @example
         * // Fill a block of 9x9 blocks, centered on the player
         * fill(rel(-4, -4, -4), rel(4, 4, 4), 'minecraft:diamond_block')
         *
         * // Fill a hollow block of 9x9 blocks, centered on the player
         * fill(rel(-4, -4, -4), rel(4, 4, 4), 'minecraft:diamond_block').hollow()
         *
         * // Replace all dirt with grass in a 9x9 blocks, centered on the player
         * fill(rel(-4, -4, -4), rel(4, 4, 4), 'minecraft:grass_block').replace('minecraft:dirt')
         */
        this.fill = (from, to, block) => FillArguments;
    }
}
__decorate([
    decorators_1.command('fill', {
        isRoot: true, executable: true, hasSubcommands: true, parsers: { '0': index_1.coordinatesParser, '1': index_1.coordinatesParser },
    }),
    __metadata("design:type", Object)
], Fill.prototype, "fill", void 0);
exports.Fill = Fill;
//# sourceMappingURL=Fill.js.map