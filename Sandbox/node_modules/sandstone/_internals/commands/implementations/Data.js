"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Data = void 0;
const index_1 = require("../../variables/index");
const Command_1 = require("../Command");
const decorators_1 = require("../decorators");
const getCmd = (name) => ['data', 'get', name];
const mergeCmd = (name) => ['data', 'merge', name];
const modifyCmd = (name) => ['data', 'modify', name];
const removeCmd = (name) => ['data', 'remove', name];
class DataGet extends Command_1.Command {
    constructor() {
        super(...arguments);
        /**
         * Get the NBT of a block at the given position.
         *
         * @param targetPos The coordinates of the block to get the NBT from.
         * @param path The path of the NBT to get.
         * @param scale The scale to multiply the NBT value by.
         */
        this.block = (targetPos, path, scale) => { };
        /**
         * Get the NBT of a given entity.
         *
         * @param target The entity to get the NBT from.
         * @param path The path of the NBT to get.
         * @param scale The scale to multiply the NBT value by.
         */
        this.entity = (target, path, scale) => { };
        /**
         * Get the NBT from a given storage path.
         *
         * @param target The storage to get the NBT from.
         * @param path The path of the NBT to get.
         * @param scale The scale to multiply the NBT value by.
         */
        this.storage = (target, path, scale) => { };
    }
}
__decorate([
    decorators_1.command(getCmd('block'), { isRoot: true, parsers: { '0': index_1.coordinatesParser } }),
    __metadata("design:type", Object)
], DataGet.prototype, "block", void 0);
__decorate([
    decorators_1.command(getCmd('entity'), { isRoot: true }),
    __metadata("design:type", Object)
], DataGet.prototype, "entity", void 0);
__decorate([
    decorators_1.command(getCmd('storage'), { isRoot: true }),
    __metadata("design:type", Object)
], DataGet.prototype, "storage", void 0);
class DataMerge extends Command_1.Command {
    constructor() {
        super(...arguments);
        /**
         * Merge the NBT of a block at the given position, with the given NBT.
         *
         * @param targetPos The coordinates of the block to merge the NBT with.
         * @param nbt The NBT to merge with.
         */
        this.block = (targetPos, nbt) => { };
        /**
         * Merge the NBT of the given entity, with the given NBT.
         *
         * @param target The entity to merge the NBT with.
         * @param nbt The NBT to merge with.
         */
        this.entity = (target, nbt) => { };
        /**
         * Merge the NBT of the given storage path, with the given NBT.
         *
         * @param target The storage to merge the NBT with.
         * @param nbt The NBT to merge with.
         */
        this.storage = (target, nbt) => { };
    }
}
__decorate([
    decorators_1.command(mergeCmd('block'), { isRoot: true, parsers: { '0': index_1.coordinatesParser } }),
    __metadata("design:type", Object)
], DataMerge.prototype, "block", void 0);
__decorate([
    decorators_1.command(mergeCmd('entity'), { isRoot: true }),
    __metadata("design:type", Object)
], DataMerge.prototype, "entity", void 0);
__decorate([
    decorators_1.command(mergeCmd('storage'), { isRoot: true }),
    __metadata("design:type", Object)
], DataMerge.prototype, "storage", void 0);
class DataModifyValues extends Command_1.Command {
    constructor() {
        super(...arguments);
        /**
         * Modify with the NBT of a block at the given position.
         *
         * @param sourcePosition The coordinates of the block to modify the NBT with.
         * @param sourcePath The path of the NBT to modify with.
         */
        this.fromBlock = (sourcePosition, sourcePath) => { };
        /**
         * Modify with the NBT of a given entity.
         *
         * @param source The entity to modify the NBT with.
         * @param sourcePath The path of the NBT to modify with.
         */
        this.fromEntity = (source, sourcePath) => { };
        /**
         * Modify with the NBT of a given storage path.
         *
         * @param source The storage path to modify the NBT with.
         * @param sourcePath The path of the NBT to modify with.
         */
        this.fromStorage = (source, sourcePath) => { };
        /**
         * Modify the NBT with the given value.
         */
        this.value = (value) => { };
    }
}
__decorate([
    decorators_1.command(['from', 'block'], { parsers: { '0': index_1.coordinatesParser } }),
    __metadata("design:type", Object)
], DataModifyValues.prototype, "fromBlock", void 0);
__decorate([
    decorators_1.command(['from', 'entity']),
    __metadata("design:type", Object)
], DataModifyValues.prototype, "fromEntity", void 0);
__decorate([
    decorators_1.command(['from', 'storage']),
    __metadata("design:type", Object)
], DataModifyValues.prototype, "fromStorage", void 0);
__decorate([
    decorators_1.command('value'),
    __metadata("design:type", Object)
], DataModifyValues.prototype, "value", void 0);
class DataModifyType extends Command_1.Command {
    constructor() {
        super(...arguments);
        /**
         * Insert the source data into the pointed-to list as element `index`, then shift higher elements one position upwards.
         *
         * @param index The index to insert the NBT to.
         */
        this.insert = (index) => new DataModifyValues(this.commandsRoot);
    }
    /** Append the source data onto the end of the pointed-to list. */
    get append() {
        this.commandsRoot.arguments.push('append');
        this.commandsRoot.executable = false;
        return new DataModifyValues(this.commandsRoot);
    }
    /** Merge the source data into the pointed-to object. */
    get merge() {
        this.commandsRoot.arguments.push('merge');
        this.commandsRoot.executable = false;
        return new DataModifyValues(this.commandsRoot);
    }
    /** Prepend the source data onto the beginning of the pointed-to list. */
    get prepend() {
        this.commandsRoot.arguments.push('prepend');
        this.commandsRoot.executable = false;
        return new DataModifyValues(this.commandsRoot);
    }
    /** Set the tag specified by `targetPath` to the source data. */
    get set() {
        this.commandsRoot.arguments.push('set');
        this.commandsRoot.executable = false;
        return new DataModifyValues(this.commandsRoot);
    }
}
__decorate([
    decorators_1.command('insert', { isRoot: false, hasSubcommands: true, executable: false }),
    __metadata("design:type", Object)
], DataModifyType.prototype, "insert", void 0);
class DataModify extends Command_1.Command {
    constructor() {
        super(...arguments);
        /**
         * Modify the NBT of a block at the given position.
         *
         * @param targetPos The coordinates of the block to modify the NBT from.
         * @param path The path of the NBT to modify.
         */
        this.block = (targetPos, targetPath) => new DataModifyType(this.commandsRoot);
        /**
         * Modify the NBT of a given entity.
         *
         * @param target The entity to modify the NBT from.
         * @param path The path of the NBT to modify.
         */
        this.entity = (target, targetPath) => new DataModifyType(this.commandsRoot);
        /**
         * Modify the NBT from a given storage path.
         *
         * @param target The storage to modify the NBT from.
         * @param path The path of the NBT to modify.
         */
        this.storage = (target, targetPath) => new DataModifyType(this.commandsRoot);
    }
}
__decorate([
    decorators_1.command(modifyCmd('block'), {
        isRoot: true, executable: false, hasSubcommands: true, parsers: { '0': index_1.coordinatesParser },
    }),
    __metadata("design:type", Object)
], DataModify.prototype, "block", void 0);
__decorate([
    decorators_1.command(modifyCmd('entity'), { isRoot: true, executable: false, hasSubcommands: true }),
    __metadata("design:type", Object)
], DataModify.prototype, "entity", void 0);
__decorate([
    decorators_1.command(modifyCmd('storage'), { isRoot: true, executable: false, hasSubcommands: true }),
    __metadata("design:type", Object)
], DataModify.prototype, "storage", void 0);
class DataRemove extends Command_1.Command {
    constructor() {
        super(...arguments);
        /**
         * Remove the NBT of a block at the given position.
         *
         * @param targetPos The coordinates of the block to remove the NBT from.
         * @param path The path of the NBT to remove.
         */
        this.block = (targetPos, targetPath) => { };
        /**
         * Remove the NBT of a given entity.
         *
         * @param target The entity to remove the NBT from.
         * @param path The path of the NBT to remove.
         */
        this.entity = (target, targetPath) => { };
        /**
         * Remove the NBT from a given storage path.
         *
         * @param target The storage to remove the NBT from.
         * @param path The path of the NBT to remove.
         */
        this.storage = (target, targetPath) => { };
    }
}
__decorate([
    decorators_1.command(removeCmd('block'), {
        isRoot: true, executable: false, hasSubcommands: true, parsers: { '0': index_1.coordinatesParser },
    }),
    __metadata("design:type", Object)
], DataRemove.prototype, "block", void 0);
__decorate([
    decorators_1.command(removeCmd('entity'), { isRoot: true, executable: false, hasSubcommands: true }),
    __metadata("design:type", Object)
], DataRemove.prototype, "entity", void 0);
__decorate([
    decorators_1.command(removeCmd('storage'), { isRoot: true, executable: false, hasSubcommands: true }),
    __metadata("design:type", Object)
], DataRemove.prototype, "storage", void 0);
/** Allows to get, merge, modify, and remove NBT data of a block entity, entity, or Command NBT storage. */
class Data extends Command_1.Command {
    constructor() {
        super(...arguments);
        /** Read off the entire NBT data or the subsection of the NBT data from the targeted block position or entity, scaled by `scale` if specified. */
        this.get = new DataGet(this.commandsRoot);
        /** Merge the NBT data from the sourced block position or entity with the specified `nbt` data. */
        this.merge = new DataMerge(this.commandsRoot);
        /** Modify the NBT data from the sourced block position or entity, with the specified operation and the given NBT. */
        this.modify = new DataModify(this.commandsRoot);
        /** Removes NBT data at `path` from the targeted block position or entity. Player NBT data cannot be removed. */
        this.remove = new DataRemove(this.commandsRoot);
    }
}
exports.Data = Data;
//# sourceMappingURL=Data.js.map