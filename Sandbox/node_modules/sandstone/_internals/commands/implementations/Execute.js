"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecuteWithRun = exports.Execute = exports.ExecuteIfData = exports.ExecuteStore = exports.ExecuteStoreArgs = void 0;
const index_1 = require("../../variables/index");
const decorators_1 = require("../decorators");
const executeConfig = {
    isRoot: false,
    hasSubcommands: true,
    executable: true,
    isExecuteSubcommand: true,
};
class CommandLike {
    constructor(commandsRootLike) {
        this.commandsRoot = commandsRootLike;
    }
}
class ExecuteSubcommand extends CommandLike {
    constructor(execute) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        super(execute.commandsRoot);
        this.execute = execute;
    }
}
function isRealCommandsRoot(commandsRootLike) {
    return Object.prototype.hasOwnProperty.call(commandsRootLike, 'register');
}
class ExecuteStoreArgs extends ExecuteSubcommand {
    constructor() {
        super(...arguments);
        /**
         * Saves the final command's return value as tag data within a block entity.
         *
         * Store as a byte, short, int, long, float, or double. If the return value is a decimal, it is rounded first and then multiplied by `scale`.
         *
         * @param targetPos Position of target block
         *
         * @param path Location of the desired tag to hold the value in.
         *
         * @param type Desired data size/type.
         *
         * @param scale Multiplier to apply before storing value.
         */
        this.block = (targetPos, path, type, scale) => this.execute;
        /**
         * Saves the final command's return value in either a bossbar's current value or its maximum value.
         *
         * @param id ID of the bossbar to target for saving.
         *
         * @param type Whether to overwrite the bossbar's current value or its max value.
         */
        this.bossbar = (id, type) => this.execute;
        /**
         * Save the final command's return value in one of an entity's data tags.
         *
         * Store as a byte, short, int, long, float, or double. If the return value is a decimal, it is rounded first and then multiplied by `scale`.
         *
         * Like the `/data` command, `/execute store <arguments>` cannot modify player NBT.
         *
         * @param target A single entity to store under.
         *
         * @param path Location of the desired tag to hold the value in.
         *
         * @param type Desired data size/type.
         *
         * @param scale Multiplier to apply before storing value.
         */
        this.entity = (target, path, type, scale) => this.execute;
        this.score = (...args) => this.execute;
        /**
         * Uses the `path` within storage `target` to store the return value in.
         *
         * Store as a byte, short, int, long, float, or double. If the return value is a decimal, it is rounded first and then multiplied by `scale`.
         *
         * If the storage does not yet exist, it gets created.
         *
         * @param target Target storage container, as a namespaced ID.
         *
         * @param path Location of the desired tag to hold the value in.
         *
         * @param type Desired data size/type.
         *
         * @param scale Multiplier to apply before storing value.
         */
        this.storage = (target, path, type, scale) => this.execute;
    }
}
__decorate([
    decorators_1.command('block', { ...executeConfig, parsers: { '0': index_1.coordinatesParser } }),
    __metadata("design:type", Object)
], ExecuteStoreArgs.prototype, "block", void 0);
__decorate([
    decorators_1.command('bossbar', executeConfig),
    __metadata("design:type", Object)
], ExecuteStoreArgs.prototype, "bossbar", void 0);
__decorate([
    decorators_1.command('entity', executeConfig),
    __metadata("design:type", Object)
], ExecuteStoreArgs.prototype, "entity", void 0);
__decorate([
    decorators_1.command('score', executeConfig),
    __metadata("design:type", Function)
], ExecuteStoreArgs.prototype, "score", void 0);
__decorate([
    decorators_1.command('storage', executeConfig),
    __metadata("design:type", Object)
], ExecuteStoreArgs.prototype, "storage", void 0);
exports.ExecuteStoreArgs = ExecuteStoreArgs;
class ExecuteStore extends ExecuteSubcommand {
    /** Store the final command's result value. */
    get result() {
        if (!this.commandsRoot.arguments.length) {
            this.commandsRoot.arguments.push('execute');
        }
        this.commandsRoot.arguments.push('store', 'result');
        if (isRealCommandsRoot(this.commandsRoot)) {
            this.commandsRoot.executable = true;
            this.commandsRoot.inExecute = true;
        }
        return new ExecuteStoreArgs(this.execute);
    }
    /** Store the final command's success value. */
    get success() {
        if (!this.commandsRoot.arguments.length) {
            this.commandsRoot.arguments.push('execute');
        }
        this.commandsRoot.arguments.push('store', 'success');
        if (isRealCommandsRoot(this.commandsRoot)) {
            this.commandsRoot.executable = true;
            this.commandsRoot.inExecute = true;
        }
        return new ExecuteStoreArgs(this.execute);
    }
}
exports.ExecuteStore = ExecuteStore;
class ExecuteIfData extends ExecuteSubcommand {
    constructor() {
        super(...arguments);
        /**
         * Checks whether the targeted block has any data for a given tag
         * @param pos Position of the block to be tested.
         * @param path Data tag to check for.
         */
        this.block = (pos, path) => this.execute;
        /**
         * Checks whether the targeted entity has any data for a given tag
         * @param target One single entity to be tested.
         * @param path Data tag to check for.
         */
        this.entity = (target, path) => this.execute;
        /**
         * Checks whether the targeted storage has any data for a given tag
         * @param source The storage to check in.
         * @param path Data tag to check for.
         */
        this.storage = (source, path) => this.execute;
    }
}
__decorate([
    decorators_1.command('block', { ...executeConfig, parsers: { '0': index_1.coordinatesParser } }),
    __metadata("design:type", Object)
], ExecuteIfData.prototype, "block", void 0);
__decorate([
    decorators_1.command('entity', executeConfig),
    __metadata("design:type", Object)
], ExecuteIfData.prototype, "entity", void 0);
__decorate([
    decorators_1.command('storage', executeConfig),
    __metadata("design:type", Object)
], ExecuteIfData.prototype, "storage", void 0);
exports.ExecuteIfData = ExecuteIfData;
class Execute extends CommandLike {
    constructor() {
        super(...arguments);
        /**
         * Updates the command's position, aligning to its current block position (an integer). Only applies along specified axes.
         * This is akin to flooring the coordinates – i.e. rounding them downwards. It updates the meaning of `~ ~ ~` and `^ ^ ^`.
         *
         * @param axes Any non-repeating combination of the characters 'x', 'y', and 'z'.
         */
        this.align = (axes) => this;
        /**
         * Stores the distance from the feet to the eyes of the entity that is executing the command in the anchor, which is part of the command context.
         * Effectively recentres `^ ^ ^` on either the eyes or feet, also changing the angle the `facing` sub-command works off of.
         *
         * @param anchor Whether to anchor the executed command to eye level or feet level
         */
        this.anchored = (anchor) => this;
        /**
         * Sets the command sender to target entity, without changing position, rotation, dimension, or anchor
         *
         * @param targets Target entity/entities to become the new sender.
         */
        this.as = (targets) => this;
        /**
         * Sets the command position, rotation, and dimension to match those of an entity/entities; does not change sender
         * @param targets Target entity/entities to match position, rotation, and dimension with
         */
        this.at = (targets) => this;
        /**
         * Sets the command rotation to face a given point, as viewed from its anchor (either the eyes or the feet).
         *
         * @param pos Coordinate to rotate towards.
         */
        this.facing = (pos) => this;
        /**
         * Sets the command rotation to face a given point, as viewed from its anchor (either the eyes or the feet).
         *
         * @param targets The target(s) to rotate towards.
         *
         * @param anchor Whether to point at the target's eyes or feet.
         */
        this.facingEntity = (targets, anchor) => this;
        /**
         * Sets the command dimension.
         *
         * @param dimension Name of the new execution dimension.
         */
        this.in = (dimension) => this;
        /**
         * Sets the command position, without changing rotation or dimension.
         *
         * @param pos The new position.
         */
        this.positioned = (pos) => this;
        /**
         * Sets the command position, without changing rotation or dimension, by matching an entity's position.
         *
         * @param targets Target entity/entities to match position with.
         */
        this.positionedAs = (targets) => this;
        /**
         * Sets the command rotation.
         *
         * @param rotation The desired rotation.
         *
         * First value is measured clockwise in degrees from due south (the +Z Axis), ranging [–180 to +180)
         * Second value is measured as declination from the horizon in degrees, ranging [–90 to +90] (straight up to straight down)
         *
         * Relative values can be used to specify a rotation relative to the current execution rotation.
         */
        this.rotated = (rotation) => this;
        /**
         * Sets the command rotation, by matching an entity's rotation.
         *
         * @param targets Target entity/entities to match rotation with.
         */
        this.rotatedAs = (targets) => this;
        /**
         * Compares the block at a given position to a given block. Suceeds if both are identical.
         *
         * @param pos Position of a target block to test.
         *
         * @param block A block to test against.
         */
        this.ifBlock = (pos, block) => this;
        /**
         * Compares the block at a given position to a given block. Succeeds if both are different.
         *
         * @param pos Position of a target block to test.
         *
         * @param block A block to test against.
         */
        this.unlessBlock = (...args) => this;
        /**
         * Compares the blocks in two equally sized volumes. Suceeds if both are identical.
         *
         * @param start Positions of the first diagonal corner of the source volume (the comparand; the volume to compare).
         *
         * @param end Positions of the second diagonal corner of the source volume (the comparand; the volume to compare)
         *
         * @param destination
         * Position of the lower northwest (the smallest X, Y and Z value) corner of the destination volume
         * (the comparator; the volume to compare to). Assumed to be of the same size as the source volume.
         *
         * @param scanMode Specifies whether all blocks in the source volume should be compared, or if air blocks should be masked/ignored.
         */
        this.ifBlocks = (start, end, destination, scanMode) => this;
        /**
         * Compares the blocks in two equally sized volumes. Suceeds if both are different.
         *
         * @param start Positions of the first diagonal corner of the source volume (the comparand; the volume to compare).
         *
         * @param end Positions of the second diagonal corner of the source volume (the comparand; the volume to compare)
         *
         * @param destination
         * Position of the lower northwest (the smallest X, Y and Z value) corner of the destination volume
         * (the comparator; the volume to compare to). Assumed to be of the same size as the source volume.
         *
         * @param scanMode Specifies whether all blocks in the source volume should be compared, or if air blocks should be masked/ignored.
         */
        this.unlessBlocks = (...args) => this;
        /**
         * Checks whether one or more entities exist. Suceeds if they do.
         *
         * @param targets The target entities to check.
         */
        this.ifEntity = (targets) => this;
        /**
         * Checks whether one or more entities exist. Suceeds if they don't.
         *
         * @param targets The target entities to check.
         */
        this.unlessEntity = (...args) => this;
        /**
         * Checks whether the `predicate` evaluates to a positive result. Suceeds if it does.
         *
         * @param predicate The predicate to test.
         */
        this.ifPredicate = (predicate) => this;
        /**
         * Checks whether the `predicate` evaluates to a positive result. Suceeds if it doesn't.
         *
         * @param predicate The predicate to test.
         */
        this.unlessPredicate = (...args) => this;
        /**
         * Check a score against either another score or a given range.
         * @param args
         */
        this.ifScore = (...args) => this;
        this.unlessScore = (...args) => this;
        // For if & unless, we're using an intermediate command because the "real" arguments are in the `.value` property of the condition
        this.if_ = (...args) => this;
        this.unless_ = (...args) => this;
        /** Checks if the given condition is met. */
        this.if = (condition) => this.if_(...condition._toMinecraftCondition().value);
        /** Checks if the given conditions is not met. */
        this.unless = (condition) => this.unless_(...condition._toMinecraftCondition().value);
        /**
         * Store the final command's result or success value somewhere.
         * It first records the location to store in, and then stores in the location after all the commands are executed.
         *
         * Note that the return values of commands must be an integer. If a decimal, it is rounded down.
         */
        this.store = new ExecuteStore(this);
    }
    /** Checks whether the targeted block, entity or storage has any data for a given tag. Suceeds if the data is found. */
    get ifData() {
        if (!this.commandsRoot.arguments.length) {
            this.commandsRoot.arguments.push('execute');
        }
        this.commandsRoot.arguments.push('if', 'data');
        if (isRealCommandsRoot(this.commandsRoot)) {
            this.commandsRoot.executable = true;
            this.commandsRoot.inExecute = true;
        }
        return new ExecuteIfData(this);
    }
    /** Checks whether the targeted block, entity or storage has any data for a given tag. Suceeds if no data is found. */
    get unlessData() {
        if (!this.commandsRoot.arguments.length) {
            this.commandsRoot.arguments.push('execute');
        }
        this.commandsRoot.arguments.push('unless', 'data');
        if (isRealCommandsRoot(this.commandsRoot)) {
            this.commandsRoot.executable = true;
            this.commandsRoot.inExecute = true;
        }
        return new ExecuteIfData(this);
    }
    /** Runs a single command. */
    get runOne() {
        return this.commandsRoot;
    }
}
__decorate([
    decorators_1.command('align', executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "align", void 0);
__decorate([
    decorators_1.command('anchored', executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "anchored", void 0);
__decorate([
    decorators_1.command('as', executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "as", void 0);
__decorate([
    decorators_1.command('at', executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "at", void 0);
__decorate([
    decorators_1.command('facing', { ...executeConfig, parsers: { '0': index_1.coordinatesParser } }),
    __metadata("design:type", Object)
], Execute.prototype, "facing", void 0);
__decorate([
    decorators_1.command(['facing', 'entity'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "facingEntity", void 0);
__decorate([
    decorators_1.command('in', executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "in", void 0);
__decorate([
    decorators_1.command('positioned', { ...executeConfig, parsers: { '0': index_1.coordinatesParser } }),
    __metadata("design:type", Object)
], Execute.prototype, "positioned", void 0);
__decorate([
    decorators_1.command(['positioned', 'as'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "positionedAs", void 0);
__decorate([
    decorators_1.command('rotated', executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "rotated", void 0);
__decorate([
    decorators_1.command(['rotated', 'as'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "rotatedAs", void 0);
__decorate([
    decorators_1.command(['if', 'block'], { ...executeConfig, parsers: { '0': index_1.coordinatesParser } }),
    __metadata("design:type", Object)
], Execute.prototype, "ifBlock", void 0);
__decorate([
    decorators_1.command(['unless', 'block'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "unlessBlock", void 0);
__decorate([
    decorators_1.command(['if', 'blocks'], { ...executeConfig, parsers: { '0': index_1.coordinatesParser, '1': index_1.coordinatesParser, '2': index_1.coordinatesParser } }),
    __metadata("design:type", Object)
], Execute.prototype, "ifBlocks", void 0);
__decorate([
    decorators_1.command(['unless', 'blocks'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "unlessBlocks", void 0);
__decorate([
    decorators_1.command(['if', 'entity'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "ifEntity", void 0);
__decorate([
    decorators_1.command(['unless', 'entity'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "unlessEntity", void 0);
__decorate([
    decorators_1.command(['if', 'predicate'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "ifPredicate", void 0);
__decorate([
    decorators_1.command(['unless', 'predicate'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "unlessPredicate", void 0);
__decorate([
    decorators_1.command(['if', 'score'], executeConfig),
    __metadata("design:type", Function)
], Execute.prototype, "ifScore", void 0);
__decorate([
    decorators_1.command(['unless', 'score'], executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "unlessScore", void 0);
__decorate([
    decorators_1.command('if', executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "if_", void 0);
__decorate([
    decorators_1.command('unless', executeConfig),
    __metadata("design:type", Object)
], Execute.prototype, "unless_", void 0);
exports.Execute = Execute;
class ExecuteWithRun extends Execute {
    constructor() {
        super(...arguments);
        /**
         * Runs a callback inside a new function.
         *
         * If the callback only creates one command, and this command is safe to be inlined, it will be inlined to avoid a useless function call.
         */
        this.run = (callback) => {
            this.commandsRoot.Datapack.flow.flowStatement(callback, {
                callbackName: `execute_${this.commandsRoot.arguments[1]}`,
                initialCondition: false,
                loopCondition: false,
            });
        };
    }
}
exports.ExecuteWithRun = ExecuteWithRun;
//# sourceMappingURL=Execute.js.map