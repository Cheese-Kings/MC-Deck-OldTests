import type { LiteralUnion } from "../../generalTypes";
import type { ANCHORS, AXES, BLOCKS, COMPARISON_OPERATORS, Coordinates, DIMENSION_TYPES, MultipleEntitiesArgument, ObjectiveArgument, Rotation, SingleEntityArgument } from "../../arguments/index";
import type { Flow } from "../../flow/index";
import type { ConditionClass, Range } from "../../variables/index";
import type { PlayerScore } from "../../variables/PlayerScore";
import type * as commands from "../../../commands";
import type { CommandsRoot } from "../CommandsRoot";
declare type StoreType = 'byte' | 'short' | 'int' | 'long' | 'float' | 'double';
declare type CommandsRootLike = CommandsRoot | Flow;
declare class CommandLike<T extends CommandsRootLike> {
    protected commandsRoot: T;
    constructor(commandsRootLike: T);
}
declare class ExecuteSubcommand<T extends CommandsRootLike> extends CommandLike<T> {
    protected execute: InferExecute<T>;
    constructor(execute: InferExecute<T>);
}
export declare class ExecuteStoreArgs<T extends CommandsRootLike> extends ExecuteSubcommand<T> {
    /**
     * Saves the final command's return value as tag data within a block entity.
     *
     * Store as a byte, short, int, long, float, or double. If the return value is a decimal, it is rounded first and then multiplied by `scale`.
     *
     * @param targetPos Position of target block
     *
     * @param path Location of the desired tag to hold the value in.
     *
     * @param type Desired data size/type.
     *
     * @param scale Multiplier to apply before storing value.
     */
    block: (targetPos: Coordinates, path: string, type: StoreType, scale: number) => InferExecute<T>;
    /**
     * Saves the final command's return value in either a bossbar's current value or its maximum value.
     *
     * @param id ID of the bossbar to target for saving.
     *
     * @param type Whether to overwrite the bossbar's current value or its max value.
     */
    bossbar: (id: string, type: 'max' | 'value') => InferExecute<T>;
    /**
     * Save the final command's return value in one of an entity's data tags.
     *
     * Store as a byte, short, int, long, float, or double. If the return value is a decimal, it is rounded first and then multiplied by `scale`.
     *
     * Like the `/data` command, `/execute store <arguments>` cannot modify player NBT.
     *
     * @param target A single entity to store under.
     *
     * @param path Location of the desired tag to hold the value in.
     *
     * @param type Desired data size/type.
     *
     * @param scale Multiplier to apply before storing value.
     */
    entity: (target: SingleEntityArgument, path: string, type: StoreType, scale: number) => InferExecute<T>;
    score: ((
    /**
     * Overrides `targets`' score on the given `objective` with the final command's return value.
     *
     * @param targets Specifies score holder(s) whose score is to be overridden.
     *
     * @param objective A scoreboard objective.
     */
    (targets: MultipleEntitiesArgument, objective: ObjectiveArgument) => InferExecute<T>) & (
    /**
     * Overrides the given player's score with the final command's return value.
     *
     * @param playerScore The player's score to override.
     */
    (playerScore: PlayerScore) => InferExecute<T>));
    /**
     * Uses the `path` within storage `target` to store the return value in.
     *
     * Store as a byte, short, int, long, float, or double. If the return value is a decimal, it is rounded first and then multiplied by `scale`.
     *
     * If the storage does not yet exist, it gets created.
     *
     * @param target Target storage container, as a namespaced ID.
     *
     * @param path Location of the desired tag to hold the value in.
     *
     * @param type Desired data size/type.
     *
     * @param scale Multiplier to apply before storing value.
     */
    storage: (target: string, path: string, type: StoreType, scale: number) => InferExecute<T>;
}
export declare class ExecuteStore<T extends CommandsRootLike> extends ExecuteSubcommand<T> {
    /** Store the final command's result value. */
    get result(): ExecuteStoreArgs<T>;
    /** Store the final command's success value. */
    get success(): ExecuteStoreArgs<T>;
}
export declare class ExecuteIfData<T extends CommandsRootLike> extends ExecuteSubcommand<T> {
    /**
     * Checks whether the targeted block has any data for a given tag
     * @param pos Position of the block to be tested.
     * @param path Data tag to check for.
     */
    block: (pos: Coordinates, path: string) => InferExecute<T>;
    /**
     * Checks whether the targeted entity has any data for a given tag
     * @param target One single entity to be tested.
     * @param path Data tag to check for.
     */
    entity: (target: SingleEntityArgument, path: string) => InferExecute<T>;
    /**
     * Checks whether the targeted storage has any data for a given tag
     * @param source The storage to check in.
     * @param path Data tag to check for.
     */
    storage: (source: string, path: string) => InferExecute<T>;
}
export declare class Execute<T extends CommandsRootLike> extends CommandLike<T> {
    /**
     * Updates the command's position, aligning to its current block position (an integer). Only applies along specified axes.
     * This is akin to flooring the coordinates – i.e. rounding them downwards. It updates the meaning of `~ ~ ~` and `^ ^ ^`.
     *
     * @param axes Any non-repeating combination of the characters 'x', 'y', and 'z'.
     */
    align: (axes: AXES) => this;
    /**
     * Stores the distance from the feet to the eyes of the entity that is executing the command in the anchor, which is part of the command context.
     * Effectively recentres `^ ^ ^` on either the eyes or feet, also changing the angle the `facing` sub-command works off of.
     *
     * @param anchor Whether to anchor the executed command to eye level or feet level
     */
    anchored: (anchor: ANCHORS) => this;
    /**
     * Sets the command sender to target entity, without changing position, rotation, dimension, or anchor
     *
     * @param targets Target entity/entities to become the new sender.
     */
    as: (targets: MultipleEntitiesArgument) => this;
    /**
     * Sets the command position, rotation, and dimension to match those of an entity/entities; does not change sender
     * @param targets Target entity/entities to match position, rotation, and dimension with
     */
    at: (targets: MultipleEntitiesArgument) => this;
    /**
     * Sets the command rotation to face a given point, as viewed from its anchor (either the eyes or the feet).
     *
     * @param pos Coordinate to rotate towards.
     */
    facing: (pos: Coordinates) => this;
    /**
     * Sets the command rotation to face a given point, as viewed from its anchor (either the eyes or the feet).
     *
     * @param targets The target(s) to rotate towards.
     *
     * @param anchor Whether to point at the target's eyes or feet.
     */
    facingEntity: (targets: MultipleEntitiesArgument, anchor: ANCHORS) => this;
    /**
     * Sets the command dimension.
     *
     * @param dimension Name of the new execution dimension.
     */
    in: (dimension: LiteralUnion<DIMENSION_TYPES>) => this;
    /**
     * Sets the command position, without changing rotation or dimension.
     *
     * @param pos The new position.
     */
    positioned: (pos: Coordinates) => this;
    /**
     * Sets the command position, without changing rotation or dimension, by matching an entity's position.
     *
     * @param targets Target entity/entities to match position with.
     */
    positionedAs: (targets: MultipleEntitiesArgument) => this;
    /**
     * Sets the command rotation.
     *
     * @param rotation The desired rotation.
     *
     * First value is measured clockwise in degrees from due south (the +Z Axis), ranging [–180 to +180)
     * Second value is measured as declination from the horizon in degrees, ranging [–90 to +90] (straight up to straight down)
     *
     * Relative values can be used to specify a rotation relative to the current execution rotation.
     */
    rotated: (rotation: Rotation) => this;
    /**
     * Sets the command rotation, by matching an entity's rotation.
     *
     * @param targets Target entity/entities to match rotation with.
     */
    rotatedAs: (targets: MultipleEntitiesArgument) => this;
    /**
     * Compares the block at a given position to a given block. Suceeds if both are identical.
     *
     * @param pos Position of a target block to test.
     *
     * @param block A block to test against.
     */
    ifBlock: (pos: Coordinates, block: LiteralUnion<BLOCKS>) => this;
    /**
     * Compares the block at a given position to a given block. Succeeds if both are different.
     *
     * @param pos Position of a target block to test.
     *
     * @param block A block to test against.
     */
    unlessBlock: this['ifBlock'];
    /**
     * Compares the blocks in two equally sized volumes. Suceeds if both are identical.
     *
     * @param start Positions of the first diagonal corner of the source volume (the comparand; the volume to compare).
     *
     * @param end Positions of the second diagonal corner of the source volume (the comparand; the volume to compare)
     *
     * @param destination
     * Position of the lower northwest (the smallest X, Y and Z value) corner of the destination volume
     * (the comparator; the volume to compare to). Assumed to be of the same size as the source volume.
     *
     * @param scanMode Specifies whether all blocks in the source volume should be compared, or if air blocks should be masked/ignored.
     */
    ifBlocks: (start: Coordinates, end: Coordinates, destination: Coordinates, scanMode: 'all' | 'masked') => this;
    /**
     * Compares the blocks in two equally sized volumes. Suceeds if both are different.
     *
     * @param start Positions of the first diagonal corner of the source volume (the comparand; the volume to compare).
     *
     * @param end Positions of the second diagonal corner of the source volume (the comparand; the volume to compare)
     *
     * @param destination
     * Position of the lower northwest (the smallest X, Y and Z value) corner of the destination volume
     * (the comparator; the volume to compare to). Assumed to be of the same size as the source volume.
     *
     * @param scanMode Specifies whether all blocks in the source volume should be compared, or if air blocks should be masked/ignored.
     */
    unlessBlocks: this['ifBlocks'];
    /** Checks whether the targeted block, entity or storage has any data for a given tag. Suceeds if the data is found. */
    get ifData(): ExecuteIfData<T>;
    /** Checks whether the targeted block, entity or storage has any data for a given tag. Suceeds if no data is found. */
    get unlessData(): ExecuteIfData<T>;
    /**
     * Checks whether one or more entities exist. Suceeds if they do.
     *
     * @param targets The target entities to check.
     */
    ifEntity: (targets: MultipleEntitiesArgument) => this;
    /**
     * Checks whether one or more entities exist. Suceeds if they don't.
     *
     * @param targets The target entities to check.
     */
    unlessEntity: this['ifEntity'];
    /**
     * Checks whether the `predicate` evaluates to a positive result. Suceeds if it does.
     *
     * @param predicate The predicate to test.
     */
    ifPredicate: (predicate: string) => this;
    /**
     * Checks whether the `predicate` evaluates to a positive result. Suceeds if it doesn't.
     *
     * @param predicate The predicate to test.
     */
    unlessPredicate: this['ifPredicate'];
    /**
     * Check a score against either another score or a given range.
     * @param args
     */
    ifScore: (
    /**
     * Check a score against either another score or a given range.
     *
     * @param target A single score holder.
     *
     * @param objective The scoreboard objective to check under.
     *
     * @param operator The comparison operator to use.
     *
     * @param source A second score holder to compare against.
     *
     * @param sourceObjective  A scoreboard objective to compare against.
     */
    (target: SingleEntityArgument, targetObjective: ObjectiveArgument, operator: COMPARISON_OPERATORS, source: SingleEntityArgument, sourceObjective: ObjectiveArgument) => this) & (
    /**
     * Check a score against either another score or a given range.
     *
     * @param target A single score holder.
     *
     * @param objective The scoreboard objective to check under.
     *
     * @param operator The comparison operator to use.
     *
     * @param range Range to compare score against.
     */
    (target: SingleEntityArgument, targetObjective: ObjectiveArgument, operator: 'matches', range: Range) => this);
    unlessScore: this['ifScore'];
    private if_;
    private unless_;
    /** Checks if the given condition is met. */
    if: (condition: ConditionClass) => this;
    /** Checks if the given conditions is not met. */
    unless: (condition: ConditionClass) => this;
    /**
     * Store the final command's result or success value somewhere.
     * It first records the location to store in, and then stores in the location after all the commands are executed.
     *
     * Note that the return values of commands must be an integer. If a decimal, it is rounded down.
     */
    store: ExecuteStore<T>;
    /** Runs a single command. */
    get runOne(): (T extends CommandsRoot ? Pick<T, ((keyof typeof commands) | 'function')> : T);
}
export declare class ExecuteWithRun<T extends CommandsRoot> extends Execute<T> {
    /**
     * Runs a callback inside a new function.
     *
     * If the callback only creates one command, and this command is safe to be inlined, it will be inlined to avoid a useless function call.
     */
    run: (callback: () => void) => void;
}
declare type InferExecute<T extends CommandsRootLike> = T extends CommandsRoot ? ExecuteWithRun<T> : Execute<T>;
export {};
