import type { LiteralUnion } from "../generalTypes";
import type { Datapack } from "../datapack/index";
import type { FunctionResource } from "../datapack/resourcesTree";
export declare type McFunctionOptions = {
    /**
     * If true, then the function will only be created if it ??
     */
    lazy?: boolean;
    /**
     * Whether to activate debugging features for the function.
     *
     * For the moment, it only adds some comments detailling what each function options & arguments are.
     *
     * It defaults to `true` if the environment variable NODE_ENV is set to `development`, else it defaults to `false`
     */
    debug?: boolean;
    /**
     * Whether the function should run each tick.
     */
    runEachTick?: boolean;
    /**
     * Whether the function should run when the datapack loads.
     */
    runOnLoad?: boolean;
    /**
     * The function tags to put this function in.
     */
    tags?: readonly string[];
};
export declare class McFunction<T extends any[]> {
    name: string;
    options: McFunctionOptions;
    alreadyInitializedParameters: Map<string, {
        mcFunction: FunctionResource;
        name: string;
    }>;
    functionsFolderResource: FunctionResource;
    datapack: Datapack;
    callback: (...args: T) => void;
    constructor(datapack: Datapack, name: string, callback: (...args: T) => void, options: McFunctionOptions);
    private createFunctionOverload;
    /**
     * Call the actual function, and triggers the given callback to add the arguments to the command.
     *
     * If `addArgumentsCallback` is not set, then no function call will be registered.
     */
    private callAndRegister;
    call: (...args: T) => void;
    schedule: (delay: number | LiteralUnion<'1t' | '1s' | '1d'>, type?: "replace" | "append" | undefined, ...args: T) => void;
    clearSchedule: (...args: T) => void;
    getNameFromArgs: (...args: T) => string;
    generateInitialFunction: () => void;
}
