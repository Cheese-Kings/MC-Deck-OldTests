"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.McFunction = void 0;
const object_hash_1 = __importDefault(require("object-hash"));
const minecraft_1 = require("../datapack/minecraft");
class McFunction {
    constructor(datapack, name, callback, options) {
        // Create an empty function, with the correct name given the overload
        this.createFunctionOverload = (args) => {
            const previousFunction = this.datapack.currentFunction;
            let newFunction;
            if (args.length === 0) {
                // Change the "folder" to specify it is a resource too.
                newFunction = Object.assign(this.functionsFolderResource, { isResource: true, commands: [] });
            }
            else {
                // Set the "folder" as the current function, and create a child of it
                this.datapack.currentFunction = this.functionsFolderResource;
                newFunction = this.datapack.createChildFunction('call').childFunction;
            }
            // Go back to the previous function
            this.datapack.currentFunction = previousFunction;
            // Return the new function
            return { newFunction, functionName: minecraft_1.toMcFunctionName(newFunction.path) };
        };
        /**
         * Call the actual function, and triggers the given callback to add the arguments to the command.
         *
         * If `addArgumentsCallback` is not set, then no function call will be registered.
         */
        this.callAndRegister = (args, addArgumentsCallback) => {
            var _a;
            const { commandsRoot } = this.datapack;
            const hashed = object_hash_1.default(args);
            const isNewOverload = !this.alreadyInitializedParameters.has(hashed);
            let name;
            let mcFunction;
            if (isNewOverload) {
                // If it's the 1st time this mcfunction is called with these arguments, we create a new overload
                const result = this.createFunctionOverload(args);
                mcFunction = result.newFunction;
                name = result.functionName;
                // Get the given tags
                let tags = (_a = this.options.tags) !== null && _a !== void 0 ? _a : [];
                // If it should run each tick, add it to the tick.json function
                if (this.options.runEachTick) {
                    tags = [...tags, 'minecraft:tick'];
                }
                // Idem for load
                if (this.options.runOnLoad) {
                    tags = [...tags, 'minecraft:load'];
                }
                for (const tag of tags) {
                    this.datapack.addFunctionToTag(name, tag);
                }
                this.alreadyInitializedParameters.set(hashed, { mcFunction, name });
            }
            else {
                const result = this.alreadyInitializedParameters.get(hashed);
                mcFunction = result === null || result === void 0 ? void 0 : result.mcFunction;
                name = result === null || result === void 0 ? void 0 : result.name;
            }
            if (addArgumentsCallback) {
                addArgumentsCallback(name);
                commandsRoot.executable = true;
                commandsRoot.register();
            }
            // Finally, if it was a new overload, we need to run the actual function
            if (isNewOverload) {
                const previousFunction = this.datapack.currentFunction;
                this.datapack.currentFunction = mcFunction;
                // Add some comments specifying the overload, and the options
                if (this.options.debug) {
                    this.datapack.commandsRoot.comment('Options:', JSON.stringify(this.options));
                    try {
                        this.datapack.commandsRoot.comment('Arguments:', JSON.stringify(args));
                    }
                    catch (e) {
                        // JSON.stringify fails on recursive objects.
                    }
                }
                this.callback(...args);
                // If there is an unfinished command, register it
                this.datapack.commandsRoot.register(true);
                // Then back to the previous one
                this.datapack.currentFunction = previousFunction;
            }
        };
        this.call = (...args) => {
            this.callAndRegister(args, (functionName) => {
                this.datapack.commandsRoot.arguments.push('function', functionName);
            });
        };
        this.schedule = (delay, type, ...args) => {
            const name = this.getNameFromArgs(...args);
            this.datapack.commandsRoot.schedule.function(name, delay, type);
        };
        this.clearSchedule = (...args) => {
            const name = this.getNameFromArgs(...args);
            this.datapack.commandsRoot.schedule.clear(name);
        };
        this.getNameFromArgs = (...args) => {
            var _a;
            const repr = object_hash_1.default(args);
            const mcfunction = this.alreadyInitializedParameters.get(repr);
            if (mcfunction) {
                return mcfunction.name;
            }
            this.callAndRegister(args);
            return (_a = this.alreadyInitializedParameters.get(repr)) === null || _a === void 0 ? void 0 : _a.name;
        };
        this.generateInitialFunction = () => {
            if (!this.options.lazy && !this.alreadyInitializedParameters.has('[]')) {
                this.callAndRegister([]);
            }
        };
        const fullPath = name.split('/');
        const realName = fullPath[fullPath.length - 1];
        const path = fullPath.slice(-1);
        this.name = name;
        this.options = { lazy: false, debug: process.env.NODE_ENV === 'development', ...options };
        this.alreadyInitializedParameters = new Map();
        this.callback = callback;
        this.datapack = datapack;
        // We "reserve" the folder by creating an empty folder there. It can be later changed to be a resource.
        const functionsPaths = datapack.getResourcePath(name);
        this.functionsFolderResource = datapack.resources.addResource('functions', {
            children: new Map(),
            isResource: false,
            path: functionsPaths.fullPathWithNamespace,
        });
        if (!options.lazy && callback.length !== 0) {
            throw new Error(`Got a parametrized function "${name}" expecting at least ${callback.length} arguments, without being lazy.\n`
                + 'Since it is not lazy, Sandstone tried to create it without passing any arguments.\n'
                + 'This is not possible. Consider putting default values to the parameters, or setting the function as lazy.');
        }
    }
}
exports.McFunction = McFunction;
//# sourceMappingURL=McFunction.js.map