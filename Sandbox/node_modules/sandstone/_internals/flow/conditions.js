"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CombinedConditions = exports.getConditionsObjective = exports.conditionToString = void 0;
function conditionToString(condition) {
    if (condition instanceof CombinedConditions) {
        return condition.toString();
    }
    return condition._toMinecraftCondition().value.join(' ');
}
exports.conditionToString = conditionToString;
function getConditionsObjective(commandsRoot) {
    return commandsRoot.Datapack.getCreateObjective('sandstone_cond', 'dummy', 'Sandstone Conditions');
}
exports.getConditionsObjective = getConditionsObjective;
class CombinedConditions {
    constructor(commandsRoot, values, operator) {
        this.removeOr = () => {
            const valuesWithoutOr = this.values.map((v) => (v instanceof CombinedConditions ? v.removeOr() : v));
            if (this.operator !== 'or') {
                return new CombinedConditions(this.commandsRoot, valuesWithoutOr, this.operator);
            }
            // We have an OR operator. We need to transform it into an AND, using De Morgan's law:
            // (A or B) = not (not A and not B)
            // This corresponds to (not A, not B, not C)
            const newValues = valuesWithoutOr.map((value) => new CombinedConditions(this.commandsRoot, [value], 'not'));
            // This corresponds to (not A and not B)
            const andCondition = new CombinedConditions(this.commandsRoot, newValues, 'and');
            // This is the final expression, not (not A and not B)
            const finalCondition = new CombinedConditions(this.commandsRoot, [andCondition], 'not');
            return finalCondition;
        };
        this.simplify = () => {
            const simplifiedValues = this.values.map((value) => (value instanceof CombinedConditions ? value.simplify() : value));
            // Simplify NOT NOT A to A
            if (this.operator === 'not') {
                const condition = simplifiedValues[0];
                if (condition instanceof CombinedConditions && condition.operator === 'not') {
                    const realCondition = condition.values[0];
                    return realCondition;
                }
            }
            const flattenedValues = simplifiedValues.flatMap((value) => {
                if (value instanceof CombinedConditions && value.operator === this.operator) {
                    return value.values;
                }
                return value;
            });
            return new CombinedConditions(this.commandsRoot, flattenedValues, this.operator);
        };
        this.toExecutes = (inverted = false) => {
            if (this.operator === 'or') {
                throw new Error('You must call removeOrs before.');
            }
            const requiredExpressions = [];
            const callableExpression = ['execute'];
            this.values.forEach((value) => {
                if (value instanceof CombinedConditions) {
                    if (value.operator === 'not' && !(value.values[0] instanceof CombinedConditions)) {
                        callableExpression.push('unless', ...value.values[0]._toMinecraftCondition().value);
                        return;
                    }
                    const executes = value.toExecutes();
                    if (value.operator === 'not') {
                        requiredExpressions.push(...executes.requiredExpressions);
                        callableExpression.push(...executes.callableExpression);
                        return;
                    }
                    const { id } = CombinedConditions;
                    CombinedConditions.id += 1;
                    const sandstoneConditions = getConditionsObjective(this.commandsRoot);
                    // An intermediate condition
                    const condition = sandstoneConditions.ScoreHolder(`cond_${id}`);
                    requiredExpressions.push(...executes.requiredExpressions);
                    requiredExpressions.push(['scoreboard', 'players', 'set', condition.toString(), '0']);
                    requiredExpressions.push([...executes.callableExpression, 'run', 'scoreboard', 'players', 'set', condition.toString(), '1']);
                    callableExpression.push(this.operator === 'not' ? 'unless' : 'if', 'score', condition.toString(), 'matches', '1');
                    return;
                }
                callableExpression.push(this.operator === 'not' ? 'unless' : 'if', ...value._toMinecraftCondition().value);
            });
            return { requiredExpressions, callableExpression };
        };
        this.values = values;
        this.operator = operator;
        this.commandsRoot = commandsRoot;
    }
    toString() {
        if (this.operator === 'not') {
            return `NOT ${conditionToString(this.values[0])}`;
        }
        const keyword = this.operator.toUpperCase();
        let result = '(';
        result += this.values.map(conditionToString).join(` ${keyword} `);
        result += ')';
        return result;
    }
}
exports.CombinedConditions = CombinedConditions;
CombinedConditions.id = 0;
//# sourceMappingURL=conditions.js.map