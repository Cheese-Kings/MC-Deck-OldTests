"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Flow = void 0;
const Execute_1 = require("../commands/implementations/Execute");
const index_1 = require("../variables/index");
const PlayerScore_1 = require("../variables/PlayerScore");
const conditions_1 = require("./conditions");
class Flow {
    constructor(commandsRoot) {
        this.block = (coords, block) => ({
            _toMinecraftCondition: () => ({ value: ['block', index_1.coordinatesParser(coords), block] }),
        });
        /** Logical operators */
        this.and = (...conditions) => new conditions_1.CombinedConditions(this.commandsRoot, conditions, 'and');
        this.or = (...conditions) => new conditions_1.CombinedConditions(this.commandsRoot, conditions, 'or');
        this.not = (...conditions) => new conditions_1.CombinedConditions(this.commandsRoot, conditions, 'not');
        /** Flow statements */
        this.flowStatement = (callback, config) => {
            var _a, _b;
            // Sometimes, there are a few arguments left inside the commandsRoot (for execute.run mostly).
            // Keep them aside, & register them after.
            const previousArguments = this.commandsRoot.arguments;
            const previousInExecute = this.commandsRoot.inExecute;
            this.commandsRoot.reset();
            const args = this.arguments.slice(1);
            // First, enter the callback
            const callbackFunctionName = this.commandsRoot.Datapack.createEnterChildFunction(config.callbackName);
            const callbackMcFunction = this.commandsRoot.Datapack.currentFunction;
            // Add its commands
            callback();
            this.commandsRoot.register(true);
            // At the end of the callback, add the given conditions to call it again
            if (config.loopCondition) {
                registerCondition(this.commandsRoot, config.condition, args);
                this.commandsRoot.inExecute = true;
                this.commandsRoot.function(callbackFunctionName);
            }
            // Exit the callback
            this.commandsRoot.Datapack.exitChildFunction();
            // Put back the old arguments
            this.commandsRoot.arguments = previousArguments;
            this.commandsRoot.inExecute = previousInExecute;
            // Register the initial condition (in the root function) to enter the callback
            if (config.initialCondition) {
                registerCondition(this.commandsRoot, config.condition, args);
                this.commandsRoot.inExecute = true;
            }
            if ((callbackMcFunction === null || callbackMcFunction === void 0 ? void 0 : callbackMcFunction.isResource) && callbackMcFunction.commands.length <= 1
                && ((_b = (_a = callbackMcFunction.commands) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b[0]) !== 'execute') {
                // If our callback only has 1 command, inline this command. We CANNOT inline executes, for complicated reasons.
                // If you want to understand the reasons, see @vdvman1#9510 explanation =>
                // https://discordapp.com/channels/154777837382008833/154777837382008833/754985742706409492
                this.commandsRoot.Datapack.resources.deleteResource(callbackMcFunction.path, 'functions');
                if (callbackMcFunction.commands.length) {
                    if (this.commandsRoot.arguments.length > 0) {
                        this.commandsRoot.arguments.push('run');
                    }
                    this.commandsRoot.addAndRegister(...callbackMcFunction.commands[0]);
                }
                else {
                    this.commandsRoot.arguments = [];
                }
            }
            else {
                // Else, register the function call
                this.commandsRoot.function(callbackFunctionName);
            }
            this.arguments = [];
        };
        this.if = (condition, callback) => {
            const conditionsObjective = conditions_1.getConditionsObjective(this.commandsRoot);
            // First, specify the `if` didn't pass yet (it's in order to chain elif/else)
            const ifScore = conditionsObjective.ScoreHolder('if_result');
            ifScore.set(0);
            this.flowStatement(() => {
                callback();
                ifScore.set(1);
            }, {
                callbackName: 'if',
                initialCondition: true,
                loopCondition: false,
                condition,
            });
            return this;
        };
        this.elseIf = (condition, callback) => {
            const conditionsObjective = conditions_1.getConditionsObjective(this.commandsRoot);
            const ifScore = conditionsObjective.ScoreHolder('if_result');
            this.flowStatement(() => {
                callback();
                ifScore.set(1);
            }, {
                callbackName: 'else_if',
                initialCondition: true,
                loopCondition: false,
                condition: this.and(ifScore.equalTo(0), condition),
            });
            return this;
        };
        this.else = (callback) => {
            const conditionsObjective = conditions_1.getConditionsObjective(this.commandsRoot);
            const ifScore = conditionsObjective.ScoreHolder('if_result');
            this.flowStatement(callback, {
                callbackName: 'else',
                initialCondition: true,
                loopCondition: false,
                condition: ifScore.equalTo(0),
            });
        };
        this.binaryMatch = (score, minimum, maximum, callback) => {
            // First, specify we didn't find a match yet
            const foundMatch = this.commandsRoot.Datapack.Variable(0);
            const callCallback = (num) => {
                this.if(this.and(score.equalTo(num), foundMatch.equalTo(0)), () => {
                    // If we found the correct score, call the callback & specify we found a match
                    callback(num);
                    foundMatch.set(1);
                });
            };
            // Recursively match the score
            const recursiveMatch = (min, max) => {
                const diff = max - min;
                if (diff < 0) {
                    return;
                }
                if (diff === 3) {
                    callCallback(min);
                    callCallback(min + 1);
                    callCallback(min + 2);
                    return;
                }
                if (diff === 2) {
                    callCallback(min);
                    callCallback(min + 1);
                    return;
                }
                if (diff === 1) {
                    callCallback(min);
                    return;
                }
                const mean = Math.floor((min + max) / 2);
                this.if(score.lowerThan(mean), () => recursiveMatch(min, mean));
                this.if(score.greaterOrEqualThan(mean), () => recursiveMatch(mean, max));
            };
            recursiveMatch(minimum, maximum);
        };
        this.while = (condition, callback) => {
            this.flowStatement(callback, {
                callbackName: 'while',
                initialCondition: true,
                loopCondition: true,
                condition,
            });
        };
        this.doWhile = (condition, callback) => {
            this.flowStatement(callback, {
                callbackName: 'doWhile',
                initialCondition: false,
                loopCondition: true,
                condition,
            });
        };
        this.binaryFor = (from, to, callback, maximum = 128) => {
            if (typeof from === 'number' && typeof to === 'number') {
                callback(to - from);
            }
            const realStart = from instanceof PlayerScore_1.PlayerScore ? from : this.commandsRoot.Datapack.Variable(from);
            const realEnd = to instanceof PlayerScore_1.PlayerScore ? to : this.commandsRoot.Datapack.Variable(to);
            const iterations = realEnd.minus(realStart);
            const _ = this;
            // For all iterations above the maximum,
            // just do a while loop that calls `maximum` times the callback,
            // until there is less than `maximum` iterations
            _.while(iterations.lowerThan(maximum), () => {
                callback(maximum);
                iterations.remove(maximum);
            });
            // There is now less iterations than the allowed MAXIMUM
            // Start the binary part
            for (let i = 1; i < maximum; i *= 2) {
                _.if(iterations.moduloBy(2).equalTo(1), () => {
                    callback(i);
                });
                iterations.dividedBy(2);
            }
        };
        this.forRange = (from, to, callback, maximum = 16) => {
            function callCallbackNTimes(n) {
                for (let i = 0; i < n; i += 1) {
                    if (callback.length > 0) {
                        callback(scoreTracker);
                        scoreTracker.add(1);
                    }
                    else {
                        // We know the callback takes no arguments - it's OK to avoid it
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-expect-error
                        callback();
                    }
                }
            }
            const scoreTracker = from instanceof PlayerScore_1.PlayerScore ? from : this.commandsRoot.Datapack.Variable(from);
            // If the callback does not use the "score" argument, we can directly set the real score
            // `scoreTracker` to the end (instead of spamming `scoreboard players add anonymous sand_ano 1`).
            if (callback.length === 0) {
                // Typescript has a bug, and will not recognize `scoreTracker.set(to)` as a valid expression. So I have to use this condition.
                if (typeof to === 'number') {
                    scoreTracker.set(to);
                }
                else {
                    scoreTracker.set(to);
                }
            }
            this.binaryFor(scoreTracker, to, callCallbackNTimes, maximum);
        };
        this.forScore = (score, 
        // eslint-disable-next-line no-shadow
        condition, 
        // eslint-disable-next-line no-shadow
        modifier, 
        // eslint-disable-next-line no-shadow
        callback) => {
            const realScore = score instanceof PlayerScore_1.PlayerScore ? score : this.commandsRoot.Datapack.Variable(score);
            const realCondition = typeof condition === 'function' ? condition(realScore) : condition;
            this.while(realCondition, () => {
                callback(realScore);
                modifier(realScore);
            });
        };
        this.commandsRoot = commandsRoot;
        this.arguments = [];
    }
    get execute() {
        return new Execute_1.Execute(this);
    }
}
exports.Flow = Flow;
function registerCondition(commandsRoot, condition, args = []) {
    let commands;
    if (condition instanceof conditions_1.CombinedConditions) {
        const realCondition = condition.removeOr().simplify();
        if (realCondition instanceof conditions_1.CombinedConditions) {
            const { callableExpression, requiredExpressions } = realCondition.toExecutes();
            commands = [...requiredExpressions, callableExpression];
        }
        else {
            commands = [['execute', ...args, 'if', ...realCondition._toMinecraftCondition().value]];
        }
    }
    else {
        commands = [['execute', ...args, 'if', ...condition._toMinecraftCondition().value]];
    }
    // Add & register all required commands
    for (const command of commands.slice(0, -1)) {
        commandsRoot.addAndRegister(...command);
    }
    // Add the callable command, WITHOUT REGISTERING IT. It must be appended with the command to run.
    const callableCommand = commands[commands.length - 1];
    commandsRoot.arguments.push(...callableCommand);
}
//# sourceMappingURL=Flow.js.map