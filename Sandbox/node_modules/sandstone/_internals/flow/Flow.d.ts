import type { LiteralUnion } from "../generalTypes";
import type { BLOCKS, Coordinates } from "../arguments/index";
import type { CommandsRoot } from "../commands/index";
import { Execute } from "../commands/implementations/Execute";
import type { CommandArgs } from "../datapack/minecraft";
import type { ConditionClass } from "../variables/index";
import { PlayerScore } from "../variables/PlayerScore";
import type { ConditionType } from "./conditions";
import { CombinedConditions } from "./conditions";
declare type FlowStatementConfig = {
    callbackName: string;
} & ({
    initialCondition: false;
    loopCondition: false;
    condition?: undefined;
} | {
    initialCondition: boolean;
    loopCondition: boolean;
    condition: ConditionType;
});
export declare class Flow {
    private commandsRoot;
    arguments: CommandArgs;
    constructor(commandsRoot: CommandsRoot);
    block: (coords: Coordinates, block: LiteralUnion<BLOCKS>) => ConditionClass;
    /** Logical operators */
    and: (...conditions: (ConditionType)[]) => CombinedConditions;
    or: (...conditions: (ConditionType)[]) => CombinedConditions;
    not: (...conditions: (ConditionType)[]) => CombinedConditions;
    /** Flow statements */
    flowStatement: (callback: () => void, config: FlowStatementConfig) => void;
    if: (condition: ConditionType, callback: () => void) => ElifElseFlow;
    elseIf: (condition: ConditionType, callback: () => void) => ElifElseFlow;
    else: (callback: () => void) => void;
    binaryMatch: (score: PlayerScore, minimum: number, maximum: number, callback: (num: number) => void) => void;
    while: (condition: ConditionClass | CombinedConditions, callback: () => void) => void;
    doWhile: (condition: ConditionClass | CombinedConditions, callback: () => void) => void;
    binaryFor: (from: PlayerScore | number, to: PlayerScore | number, callback: (amount: number) => void, maximum?: number) => void;
    forRange: (from: PlayerScore | number, to: PlayerScore | number, callback: (score: PlayerScore) => void, maximum?: number) => void;
    forScore: (score: PlayerScore | number, condition: ConditionClass | CombinedConditions | ((score: PlayerScore) => ConditionType), modifier: (score: PlayerScore) => void, callback: (score: PlayerScore) => void) => void;
    get execute(): Omit<Execute<Flow>, 'run' | 'runOne'>;
}
export declare type PublicFlow = Omit<Flow, 'arguments' | 'flowStatement' | 'elseIf' | 'else'>;
declare type ElifElseFlow = Pick<Flow, 'elseIf' | 'else'>;
export {};
