"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectorCreator = exports.SelectorClass = void 0;
const abstractClasses_1 = require("./abstractClasses");
// Sanitize score values. null => '', Infinity => '', any number => itself
function sanitizeValue(value) {
    if (value === undefined || value === null) {
        return '';
    }
    if (Number.isFinite(value)) {
        return value.toString();
    }
    // Value is Infinity or -Infinity
    return '';
}
// Returns the string representation of a score range. [0, null] => '0..', [-Infinity, 5] => '..5', 8 => '8'
function parseScore(scores) {
    return `{${Object.entries(scores).map(([scoreName, value]) => {
        if (Array.isArray(value)) {
            return [scoreName, `${sanitizeValue(value[0])}..${sanitizeValue(value[1])}`].join('=');
        }
        return [scoreName, value].join('=');
    }).join(', ')}}`;
}
// Returns the string representation of advancements
function parseAdvancements(advancements) {
    return `{${Object.entries(advancements).map(([advancementName, value]) => {
        if (typeof value === 'boolean') {
            return [advancementName, value].join('=');
        }
        return [advancementName, parseAdvancements(value)].join('=');
    }).join(', ')}}`;
}
class SelectorClass extends abstractClasses_1.ComponentClass {
    constructor(commandsRoot, target, selectorArguments) {
        super();
        // Custom actions //
        /**
         * List all scores of this entity.
         */
        this.listScores = () => {
            this.commandsRoot.scoreboard.players.list(this.toString());
        };
        this.commandsRoot = commandsRoot;
        this.target = target;
        this.arguments = selectorArguments !== null && selectorArguments !== void 0 ? selectorArguments : {};
    }
    _toMinecraftCondition() {
        return { value: ['entity', this] };
    }
    toString() {
        if (!Object.keys(this.arguments).length) {
            return this.target;
        }
        const result = [];
        if (this.arguments) {
            const args = { ...this.arguments };
            const modifiers = {
                // Parse scores
                scores: (scores) => result.push(['scores', parseScore(scores)]),
                // Parse advancements
                advancements: (advancements) => result.push(['advancements', parseAdvancements(advancements)]),
                // Parse potentially multiple tags
                tag: (tag) => {
                    const tags = Array.isArray(tag) ? tag : [tag];
                    result.push(...tags.map((tag_) => ['tag', tag_]));
                },
                // Parse potentially multiple predicates
                predicate: (predicate) => {
                    const predicates = Array.isArray(predicate) ? predicate : [predicate];
                    result.push(...predicates.map((pred) => ['predicate', pred]));
                },
                // Handle boolean values for teams
                team: (team) => {
                    let teamRepr;
                    if (team === true) {
                        teamRepr = '!';
                    }
                    else if (team === false) {
                        teamRepr = '';
                    }
                    else {
                        teamRepr = team;
                    }
                    result.push(['team', teamRepr]);
                },
            };
            for (const [baseName, modifier] of Object.entries(modifiers)) {
                const name = baseName;
                const value = args[name];
                if (value !== undefined) {
                    modifier(value);
                    delete args[name];
                }
            }
            Object.entries(args).forEach(([key, value]) => {
                if (value !== undefined) {
                    result.push([key, value.toString()]);
                }
            });
        }
        return `${this.target}[${result.map(([key, value]) => `${key}=${value}`).join(', ')}]`;
    }
    _toChatComponent() {
        return {
            selector: this.toString(),
        };
    }
    toJSON() {
        return this.toString();
    }
}
exports.SelectorClass = SelectorClass;
function SelectorCreator(target, selectorArguments) {
    return new SelectorClass(this, target, selectorArguments);
}
exports.SelectorCreator = SelectorCreator;
//# sourceMappingURL=Selector.js.map